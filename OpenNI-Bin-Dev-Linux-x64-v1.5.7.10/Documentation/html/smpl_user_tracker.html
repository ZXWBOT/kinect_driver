<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenNI 1.5.7: NiUserTracker - sample program</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="OpenNILogo.bmp"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenNI 1.5.7
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">OpenNI Overview</a>      </li>
      <li class="navelem"><a class="el" href="smpls_n_guides.html">Samples and Guides</a>      </li>
      <li class="navelem"><a class="el" href="smpls.html">Sample Programs for the OpenNI API</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">NiUserTracker - sample program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Source files:</b> Click the following link to view the source code file:</p>
<ul>
<li>NiUserTracker\main.cpp</li>
<li>opengles.cpp</li>
<li>SceneDrawer.cpp</li>
</ul>
<p>This section describes the NiUserTracker sample program written in C++. The executable program for Windows is NiUserTracker.exe.</p>
<p>The documentation describes the sample program's code from the top of the program file to bottom.</p>
<p>Every OpenNI feature is described the first time it appears in this sample program. Further appearances of the same feature are not described again.</p>
<p>FILE NAME: main.cpp</p>
<h2><a class="anchor" id="utcpp_glb_dcl_blk"></a>
Global Declaration Block</h2>
<p>The following declarations define the OpenNI objects required for building the OpenNI production graph. The production graph is the main object model in OpenNI.</p>
<div class="fragment"><pre class="fragment">            <a class="code" href="classxn_1_1_context.html">xn::Context</a> g_Context;
            <a class="code" href="classxn_1_1_script_node.html">xn::ScriptNode</a> g_scriptNode;
            <a class="code" href="classxn_1_1_depth_generator.html">xn::DepthGenerator</a> g_DepthGenerator;
            <a class="code" href="classxn_1_1_user_generator.html">xn::UserGenerator</a> g_UserGenerator;
            <a class="code" href="classxn_1_1_player.html">xn::Player</a> g_Player;
</pre></div><p>Each of these concepts is described separately in the following paragraphs.</p>
<p>The <em>production graph</em> is a network of software objects - called production nodes - that can identify blobs as hands or human users. In this sample program the production graph identifies blobs as human users, and tracks them as they move. See <a class="el" href="prod_graph.html">The Production Graph</a> for more about the production graph.</p>
<p>A <a class="el" href="classxn_1_1_context.html">xn::Context</a> object is a workspace in which the application builds an OpenNI production graph.</p>
<p>The <a class="el" href="classxn_1_1_script_node.html">xn::ScriptNode</a> object loads an XML script from a file or string, and then runs the XML script to build a production graph. The ScriptNode object must be kept alive as long as the other nodes are needed.</p>
<p>A <a class="el" href="classxn_1_1_depth_generator.html">xn::DepthGenerator</a> node generates a depth map. Each map pixel value represents a distance from the sensor.</p>
<p>A <a class="el" href="classxn_1_1_user_generator.html">xn::UserGenerator</a> node generates data describing users that it recognizes in the scene, identifying each user individually and thus allowing actions to be done on specific users. The single UserGenerator node gets data for all users appearing in the scene.</p>
<p>A <a class="el" href="classxn_1_1_player.html">xn::Player</a> node plays a saved recording of an OpenNI data generation session.</p>
<h2><a class="anchor" id="utcpp_release"></a>
CleanupExit() function -- Release the Nodes</h2>
<p>This function releases the OpenNI nodes. Releasing the nodes unreferences them, decreasing their reference counts by 1. If a node's reference count reaches zero, it will be destroyed. In this sample program the result of this function should be the destruction of all the nodes. void CleanupExit() { g_scriptNode.Release(); g_DepthGenerator.Release(); g_UserGenerator.Release(); g_Player.Release(); g_Context.Release(); exit (1); }</p>
<h2><a class="anchor" id="utcpp_event_handlers"></a>
Declarations of Event Handlers</h2>
<p>This section describes the event handlers this sample program requires, describing the nature of the events themselves and what is done inside the handlers.</p>
<p>A typical order of invocation of the events in the default configuration, where online-calibration is enabled, would be: 1. 'New User' event 2. 'Calibration Complete' event 3. 'Lost User' event</p>
<p>Online-calibration enables the acquisition of a skeleton without the need for poses. The events are described below in order of their declaration in the source code.</p>
<p>Note: When online-calibration is turned off ( which is <em>not </em> the default configuration) a 'Pose Detected' event would typically occur after the 'New User' event and before the Calibration Complete' event.</p>
<h3><a class="anchor" id="utj_newuser_ev_hndlr"></a>
'New User' event handler</h3>
<p>The <b>'New User' event</b> signals that a new user has now been recognized in the scene. A new user is a user that was not previously recognized in the scene, and is now recognized in the scene. The user is identified by a persistent ID.</p>
<p>Below is a typical implementation of the event handler. It's processing is as follows. Now that a new user has been detected, the handler calls <a class="el" href="classxn_1_1_pose_detection_capability.html#a8ba21d0b1a6ba12a89fd0100e980121a">StartPoseDetection()</a> to start pose detection. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordtype">void</span> XN_CALLBACK_TYPE User_NewUser(<a class="code" href="classxn_1_1_user_generator.html">xn::UserGenerator</a>&amp; generator, <a class="code" href="_xn_types_8h.html#a83a03695bbf1ac00ac01d39ad21f01aa">XnUserID</a> nId, <span class="keywordtype">void</span>* pCookie)
                {
                    XnUInt32 epochTime = 0;
                    <a class="code" href="_xn_o_s_8h.html#a8cda4856cd995f10dec4aca69a0ca1a8">xnOSGetEpochTime</a>(&amp;epochTime);
                    printf(<span class="stringliteral">&quot;%d New User %d\n&quot;</span>, epochTime, nId);
                    <span class="comment">// New user found</span>
                    <span class="keywordflow">if</span> (g_bNeedPose)
                    {
                        g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#a99ffd208ee85c90dde7c6d9e13b22fd8" title="Gets a xn::PoseDetectionCapability object for accessing Pose Detection functionality.">GetPoseDetectionCap</a>().<a class="code" href="classxn_1_1_pose_detection_capability.html#a8ba21d0b1a6ba12a89fd0100e980121a" title="Starts attempting to detect a pose for a specific user.">StartPoseDetection</a>(g_strPose, nId);
                    }
                    <span class="keywordflow">else</span>
                    {
                        g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#a3428d28764b594a2816f5aa314188234" title="Starts the calibration process to calibrate a user.">RequestCalibration</a>(nId, TRUE);
                    }
                }
</pre></div><h3><a class="anchor" id="utcpp_lostuser_ev_hndlr"></a>
'Lost User' event handler</h3>
<p>The <b>'Lost User' event</b> signals that a user has been lost from the list of previously recognized users in the scene. The exact meaning of a 'lost user' is decided by the developer of the <a class="el" href="classxn_1_1_user_generator.html">xn::UserGenerator</a>. However, a typical implementation would define that a lost user is a previously recognized user that then exits the scene and does not return, even after a 'Lost User' timeout has elapsed. Thus this event might be raised only after some delay after the user actually exited the scene.</p>
<p>Below is a typical implementation of the event handler. It's processing is as follows. Now that an existing user has been lost, the handler deletes the user's entry from the <a class="el" href="smpl_user_tracker_net.html#utcs_init_joints_array">Initializes the 'joints' Array</a> <code>joints</code> array. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordtype">void</span> XN_CALLBACK_TYPE User_LostUser(<a class="code" href="classxn_1_1_user_generator.html">xn::UserGenerator</a>&amp; generator, <a class="code" href="_xn_types_8h.html#a83a03695bbf1ac00ac01d39ad21f01aa">XnUserID</a> nId, <span class="keywordtype">void</span>* pCookie)
                {
                    XnUInt32 epochTime = 0;
                    <a class="code" href="_xn_o_s_8h.html#a8cda4856cd995f10dec4aca69a0ca1a8">xnOSGetEpochTime</a>(&amp;epochTime);
                    printf(<span class="stringliteral">&quot;%d Lost user %d\n&quot;</span>, epochTime, nId);    
                }
</pre></div><h3><a class="anchor" id="utcpp_posedetect_ev_hndlr"></a>
'Pose Detected' event handler</h3>
<p>The <b>'Pose Detected' event</b> signals that a human user made the pose named in the call to the StartPoseDetection() method. The user is designated with the ID given by the <code>nID</code> parameter.</p>
<p>Below is a typical implementation of the event handler. It's processing is as follows. Now that a pose has been detected, the handler calls <a class="el" href="classxn_1_1_pose_detection_capability.html#a5ecc3fc3aa1fbd7fbe0a01d3d0c105bc">StopPoseDetection()</a> to stop pose detection. The handler then calls <a class="el" href="classxn_1_1_skeleton_capability.html#a3428d28764b594a2816f5aa314188234">requestSkeletonCalibration()</a> to start calibration. The <code>true</code> disregards any previous calibration and forces a new calibration. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordtype">void</span> XN_CALLBACK_TYPE UserPose_PoseDetected(<a class="code" href="classxn_1_1_pose_detection_capability.html">xn::PoseDetectionCapability</a>&amp; capability, <span class="keyword">const</span> XnChar* strPose, <a class="code" href="_xn_types_8h.html#a83a03695bbf1ac00ac01d39ad21f01aa">XnUserID</a> nId, <span class="keywordtype">void</span>* pCookie)
                {
                    XnUInt32 epochTime = 0;
                    <a class="code" href="_xn_o_s_8h.html#a8cda4856cd995f10dec4aca69a0ca1a8">xnOSGetEpochTime</a>(&amp;epochTime);
                    printf(<span class="stringliteral">&quot;%d Pose %s detected for user %d\n&quot;</span>, epochTime, strPose, nId);
                    g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#a99ffd208ee85c90dde7c6d9e13b22fd8" title="Gets a xn::PoseDetectionCapability object for accessing Pose Detection functionality.">GetPoseDetectionCap</a>().<a class="code" href="classxn_1_1_pose_detection_capability.html#a5ecc3fc3aa1fbd7fbe0a01d3d0c105bc" title="Stops attempting to detect a pose (for a specific user).">StopPoseDetection</a>(nId);
                    g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#a3428d28764b594a2816f5aa314188234" title="Starts the calibration process to calibrate a user.">RequestCalibration</a>(nId, TRUE);
                }
</pre></div><h3><a class="anchor" id="utcpp_calibstart_ev_hndlr"></a>
'Calibration Start' event handler</h3>
<p>The <b>'Calibration Start' event</b> signals that Signals that a specific user's SkeletonCapability object is now starting the calibration process.</p>
<p>Below is a typical implementation of the event handler. It has no OpenNI specific code. It just records the time the handler was called and then prints it out. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordtype">void</span> XN_CALLBACK_TYPE UserCalibration_CalibrationStart(<a class="code" href="classxn_1_1_skeleton_capability.html">xn::SkeletonCapability</a>&amp; capability, <a class="code" href="_xn_types_8h.html#a83a03695bbf1ac00ac01d39ad21f01aa">XnUserID</a> nId, <span class="keywordtype">void</span>* pCookie)
                {
                    XnUInt32 epochTime = 0;
                    <a class="code" href="_xn_o_s_8h.html#a8cda4856cd995f10dec4aca69a0ca1a8">xnOSGetEpochTime</a>(&amp;epochTime);
                    printf(<span class="stringliteral">&quot;%d Calibration started for user %d\n&quot;</span>, epochTime, nId);
                }
</pre></div><h3><a class="anchor" id="utcpp_calibcmplt_ev_hndlr"></a>
'Calibration Complete' event handler</h3>
<p>The <b>'Calibration Complete' event</b> signals that a specific user's skeleton has now completed the calibration process, and provides a result status. The user is identified by the ID given by the <code>nId</code> parameter.</p>
<p>Below is a typical implementation of the event handler. It's processing is as follows. The handler tests whether the calibration process was completed successfully. If successful, that means that a user has been detected and calibrated, and enough information has been obtained to create a skeleton to represent the user.</p>
<p>The handler then advances the processing to the next stage, i.e., to call <a class="el" href="classxn_1_1_hands_generator.html#ac60c64231895f76465d795b3ca603778">StartTracking()</a> to start tracking the skeleton, which represents a human user body, within a real-life (3D) scene for analysis, interpretation, and use by the application. (Description continued after the code.) </p>
<div class="fragment"><pre class="fragment">                <span class="keywordtype">void</span> XN_CALLBACK_TYPE UserCalibration_CalibrationComplete(<a class="code" href="classxn_1_1_skeleton_capability.html">xn::SkeletonCapability</a>&amp; capability, <a class="code" href="_xn_types_8h.html#a83a03695bbf1ac00ac01d39ad21f01aa">XnUserID</a> nId, <a class="code" href="_xn_types_8h.html#ac58d2e4f6ca6abf9d55cdd9377449a77">XnCalibrationStatus</a> eStatus, <span class="keywordtype">void</span>* pCookie)
                {
                    ...
                    <span class="keywordflow">if</span> (eStatus == <a class="code" href="_xn_types_8h.html#ac58d2e4f6ca6abf9d55cdd9377449a77a7e48dedb8aaa2619f73f52647681d9e2">XN_CALIBRATION_STATUS_OK</a>)
                    {
                        ...
                        g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#a9b6c1de717298ff1540e32c6d2c02260" title="Starts tracking a skeleton.">StartTracking</a>(nId);
                    }
                    <span class="keywordflow">else</span>
                    {
                        printf(<span class="stringliteral">&quot;%d Calibration failed for user %d\n&quot;</span>, epochTime, nId);
                        <span class="keywordflow">if</span> (g_bNeedPose)
                        {
                            g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#a99ffd208ee85c90dde7c6d9e13b22fd8" title="Gets a xn::PoseDetectionCapability object for accessing Pose Detection functionality.">GetPoseDetectionCap</a>().<a class="code" href="classxn_1_1_pose_detection_capability.html#a8ba21d0b1a6ba12a89fd0100e980121a" title="Starts attempting to detect a pose for a specific user.">StartPoseDetection</a>(g_strPose, nId);
                        }
                        <span class="keywordflow">else</span>
                        {
                            g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#a3428d28764b594a2816f5aa314188234" title="Starts the calibration process to calibrate a user.">RequestCalibration</a>(nId, TRUE);
                        }
                    }
                }
</pre></div><p>In the above handler, if the calibration process failed, the handler restarts the whole calibration sequence. The way the handler restarts the calibration sequence depends on whether the specific generator demands detecting a pose before starting calibration . If a pose is required, the program calls <a class="el" href="classxn_1_1_pose_detection_capability.html#a8ba21d0b1a6ba12a89fd0100e980121a">StartPoseDetection()</a> to start attempting to detect a pose for a specific user.</p>
<p>If a pose is not required, the program calls <a class="el" href="classxn_1_1_user_generator.html#ac41196c59912826bb5eab3ce644cdcfb">GetSkeletonCap()</a>.<a class="el" href="classxn_1_1_skeleton_capability.html#a3428d28764b594a2816f5aa314188234" title="Starts the calibration process to calibrate a user.">xn::SkeletonCapability::RequestCalibration()</a> "RequestCalibration()". <a class="el" href="classxn_1_1_user_generator.html#ac41196c59912826bb5eab3ce644cdcfb">GetSkeletonCap()</a> gets a <a class="el" href="classxn_1_1_skeleton_capability.html">SkeletonCapability</a> object for accessing Skeleton functionality. the <a class="el" href="classxn_1_1_skeleton_capability.html#a3428d28764b594a2816f5aa314188234">RequestCalibration()</a> method starts the calibration process to calibrate a user. The TRUE parameter means to disregard previous calibration to force a further calibration.</p>
<h2><a class="anchor" id="utcpp_sample_xml_path"></a>
Declaration of Path to Sample XML File</h2>
<p>The following definition is for the path to an OpenNI XML script file. This file is for inputting and building a stored production graph. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">                #define SAMPLE_XML_PATH &quot;../../../../Data/SamplesConfig.xml&quot;</span>
</pre></div><h2><a class="anchor" id="utcpp_fnSaveCalibration"></a>
SaveCalibration() function</h2>
<p>This routine saves to a file the skeleton calibration data of the first user that it finds is calibrated. . This is a very useful tool for developers. They can save their own calibration, and test their application again without calibrating each time (going into pose, spend time on calibration). </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">            #define XN_CALIBRATION_FILE_NAME &quot;UserCalibration.bin&quot;</span>
<span class="preprocessor"></span>
            <span class="keywordtype">void</span> SaveCalibration()
            {
                <a class="code" href="_xn_types_8h.html#a83a03695bbf1ac00ac01d39ad21f01aa">XnUserID</a> aUserIDs[20] = {0};
                XnUInt16 nUsers = 20;
                g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#a174c171f0094266c7ee51a0eb1844e86" title="Gets an array of user IDs of all the recognized users in the scene at the current time...">GetUsers</a>(aUserIDs, nUsers);
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nUsers; ++i)
                {
                    <span class="comment">// Find a user who is already calibrated</span>
                    <span class="keywordflow">if</span> (g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#a3d0ac975165ef69497bd50c1127dc806" title="Returns whether a user has been calibrated. see Calibration.">IsCalibrated</a>(aUserIDs[i]))
                    {
                        <span class="comment">// Save user&#39;s calibration to file</span>
                        g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#a318da325962182710b547b7efdf5e912" title="Saves the skeleton&#39;s current calibration data to a file.">SaveCalibrationDataToFile</a>(aUserIDs[i], XN_CALIBRATION_FILE_NAME);
                        <span class="keywordflow">break</span>;
                    }
                }
            }   
</pre></div><p>From the code above:</p>
<p>The <code>GetUsers()</code> gets user skeleton calibration data and places it in the <code>aUserIDs</code> array, with one entry per user. Then in the 'save' loop, later on, the code loops through each user in turn testing if it has been calibrated, and when it finds the first calibrated user it saves its calibration data to a file, XN_CALIBRATION_FILE_NAME defined as "UserCalibration.bin" above.</p>
<h2><a class="anchor" id="utcpp_fnLoadCalibration"></a>
LoadCalibration() function</h2>
<p>The following routine loads the user skeleton calibration data from a file. This is a very useful tool for developers. They can save their own calibration, and test their application again without calibrating each time (going into pose, spend time on calibration). The code loads data only for the first found user that is not yet calibrated or in the middle of being calibrated. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordtype">void</span> LoadCalibration()
                {
                    <a class="code" href="_xn_types_8h.html#a83a03695bbf1ac00ac01d39ad21f01aa">XnUserID</a> aUserIDs[20] = {0};
                    XnUInt16 nUsers = 20;
                    g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#a174c171f0094266c7ee51a0eb1844e86" title="Gets an array of user IDs of all the recognized users in the scene at the current time...">GetUsers</a>(aUserIDs, nUsers);
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nUsers; ++i)
                    {
                        <span class="comment">// Find a user who isn&#39;t calibrated or currently in pose</span>
                        <span class="keywordflow">if</span> (g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#a3d0ac975165ef69497bd50c1127dc806" title="Returns whether a user has been calibrated. see Calibration.">IsCalibrated</a>(aUserIDs[i])) <span class="keywordflow">continue</span>;
                        <span class="keywordflow">if</span> (g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#aa86d9246c806eacb6fd626290d4cf0e7" title="Returns whether a user is being calibrated right now. see Calibration.">IsCalibrating</a>(aUserIDs[i])) <span class="keywordflow">continue</span>;

                        <span class="comment">// Load user&#39;s calibration from file</span>
                        <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> rc = g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#a671f9f5512df03cad3ad57380d9c47ba" title="Loads skeleton calibration data from a file to a skeleton.">LoadCalibrationDataFromFile</a>(aUserIDs[i], XN_CALIBRATION_FILE_NAME);
                        <span class="keywordflow">if</span> (rc == <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>)
                        {
                            <span class="comment">// Make sure state is coherent</span>
                            g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#a99ffd208ee85c90dde7c6d9e13b22fd8" title="Gets a xn::PoseDetectionCapability object for accessing Pose Detection functionality.">GetPoseDetectionCap</a>().<a class="code" href="classxn_1_1_pose_detection_capability.html#a5ecc3fc3aa1fbd7fbe0a01d3d0c105bc" title="Stops attempting to detect a pose (for a specific user).">StopPoseDetection</a>(aUserIDs[i]);
                            g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().xn::(aUserIDs[i]);
                        }
                        <span class="keywordflow">break</span>;
                    }
                }   
</pre></div><h2><a class="anchor" id="ytcpp_glut_display"></a>
glutDisplay() method</h2>
<p>This function is called each frame. There are no OpenNI-specific declarations in this function.</p>
<h2><a class="anchor" id="ytcpp_glut_idle"></a>
glutIdle() method</h2>
<p>There are no OpenNI-specific declarations in this function.</p>
<h2><a class="anchor" id="ytcpp_glut_keyboard"></a>
glutKeyboard() method</h2>
<p>There are no OpenNI-specific declarations in this function.</p>
<h2><a class="anchor" id="ytcpp_glInit"></a>
glutKeyboard() method</h2>
<p>There are no OpenNI-specific declarations in this function.</p>
<p>The CHECK_RC() macro checks whether the most recent OpenNI operation was successful or returned an error result. On error, the <a class="el" href="_xn_status_8h.html#a709a2190465f4a6d7893587e53d66798">xnGetStatusString()</a> method converts the OpenNI error return code to the corresponding error string for printing. For the sake of conciseness, the rest of this documentation skips calls to this macro. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">            #define CHECK_RC(rc, what) \</span>
<span class="preprocessor">              ...</span>
</pre></div><h2><a class="anchor" id="utcpp_fnglutDisplay"></a>
glutDisplay() function</h2>
<p>This routine graphically displays the data on a screen.</p>
<p>The following declare metadata objects to provide frame objects for the <a class="el" href="classxn_1_1_depth_generator.html">xn::DepthGenerator</a> node and for the <a class="el" href="classxn_1_1_user_generator.html">xn::UserGenerator</a> node. A <a class="el" href="glossary.html#dict_gen_node">generator node's</a> <a class="el" href="glossary.html#glos_frame_object">frame object</a> stores a generated data frame and all its associated properties. This data frame and its properties are accessible through the node's metadata object. </p>
<div class="fragment"><pre class="fragment">            <a class="code" href="classxn_1_1_scene_meta_data.html">xn::SceneMetaData</a> sceneMD;
            <a class="code" href="classxn_1_1_depth_meta_data.html">xn::DepthMetaData</a> depthMD;
</pre></div><p>In the following statements, the <a class="el" href="classxn_1_1_depth_meta_data.html">DepthGenerator frame object</a> is used to access the <a class="el" href="classxn_1_1_map_meta_data.html#a88773e165cbc69e091e87781ca43bdb7">XRes()</a> and <a class="el" href="classxn_1_1_map_meta_data.html#a88773e165cbc69e091e87781ca43bdb7">YRes()</a> methods. These methods return the X and Y dimensions of the depth buffer. These values are used for stepping through the depth map buffer to get the individual pixel values.</p>
<div class="fragment"><pre class="fragment">            g_DepthGenerator.<a class="code" href="classxn_1_1_depth_generator.html#a0e05087d3c1652e6f7fa4c002807a22a" title="Gets the depth generator node&#39;s latest frame object, saving it in the xn::DepthMetaData object...">GetMetaData</a>(depthMD);
<span class="preprocessor">            #ifndef USE_GLES</span>
<span class="preprocessor"></span>                glOrtho(0, depthMD.<a class="code" href="classxn_1_1_map_meta_data.html#a597e11801d9305dfa4c1f78ec249bf0a">XRes</a>(), depthMD.<a class="code" href="classxn_1_1_map_meta_data.html#a4daff8222744af42afbb8114600967f9">YRes</a>(), 0, -1.0, 1.0);
<span class="preprocessor">            #else</span>
<span class="preprocessor"></span>                glOrthof(0, depthMD.<a class="code" href="classxn_1_1_map_meta_data.html#a597e11801d9305dfa4c1f78ec249bf0a">XRes</a>(), depthMD.<a class="code" href="classxn_1_1_map_meta_data.html#a4daff8222744af42afbb8114600967f9">YRes</a>(), 0, -1.0, 1.0);
<span class="preprocessor">            #endif</span>
</pre></div><p>the <a class="el" href="classxn_1_1_context.html#ad4bab84f35a855639d485da99a05c585">WaitOneUpdateAll()</a> method in the following statement updates the application buffer of each and every node in the entire production graph, but first waiting for a specified node to have generated a new data frame. The application can then get the new data (for example, using a metadata <code>GetData()</code> method). The WaitOneUpdateAll() method has a timeout. In this sample program, the following statement updates the production graph only if the <a class="el" href="classxn_1_1_user_generator.html">UserGenerator</a> node has new data. </p>
<div class="fragment"><pre class="fragment">            g_Context.<a class="code" href="classxn_1_1_context.html#ad4bab84f35a855639d485da99a05c585" title="Updates all generator nodes in the context to their latest available data, first waiting for a specif...">WaitOneUpdateAll</a>(g_UserGenerator);
</pre></div><p>The following code block gets the frame objects to use them to draw the depth map, users, and skeletons. Frame objects are a snapshot of the generated map data and its associated configuration information at a certain point in time. Frame objects provide fast and easy access to the DepthGenerator node's data and configuration information.</p>
<div class="fragment"><pre class="fragment">            g_DepthGenerator.<a class="code" href="classxn_1_1_depth_generator.html#a0e05087d3c1652e6f7fa4c002807a22a" title="Gets the depth generator node&#39;s latest frame object, saving it in the xn::DepthMetaData object...">GetMetaData</a>(depthMD);
            g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#aa302a10f2f6f13174a2e2a5bf1746a10" title="Gets the pixel map of the specified user in the scene and saves it in the xn::SceneMetaData object...">GetUserPixels</a>(0, sceneMD);
            DrawDepthMap(depthMD, sceneMD);
</pre></div><p>In the above, The <a class="el" href="classxn_1_1_depth_generator.html#a0e05087d3c1652e6f7fa4c002807a22a">GetMetaData()</a> gets the DepthGenerator node's <a class="el" href="glossary.html#glos_frame_object">frame object</a>, saving it in the <a class="el" href="classxn_1_1_depth_meta_data.html">xn::DepthMetaData</a> object.</p>
<p><a class="el" href="classxn_1_1_user_generator.html#aa302a10f2f6f13174a2e2a5bf1746a10">GetUserPixels()</a> gets the pixel map of the specified user. This is a pixel map of the entire scene saved as a frame object, where the pixels that represent the body are labeled with user IDs. Each pixel is labeled with the ID of the user that contains that pixel.</p>
<h2><a class="anchor" id="utcpp_func_main"></a>
main() - Main Program</h2>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
            {
                ...
            }
</pre></div><h3><a class="anchor" id="utcpp_init_prod_graph"></a>
Initializing the Production Graph</h3>
<p>The main program starts by initializing an OpenNI status flag and then initializes the production graph (see the following code). If the program is invoked with a parameter containing a recording name, the program initializes the production graph from the recording file. Otherwise, it initializes the production graph from the standard OpenNI XML file. </p>
<div class="fragment"><pre class="fragment">                <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> nRetVal = <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>;
                <span class="keywordflow">if</span> (argc &gt; 1)
                {
                  <span class="comment">// Here the production graph is initialized from a recording </span>
                }
                <span class="keywordflow">else</span>
                {
                  <span class="comment">// Here the production graph is initialized from the standard OpenNI XML file </span>
                }
</pre></div><p><b>Production graph initialized from recording:</b> In the following code block, g_Context.Init() initializes the context. The call to g_Context.xn::Context::OpenFileRecording() "OpenFileRecording()" then opens a recording file. The argv[1] parameter supplies the name of the recording file. The g_Player parameter returns a <a class="el" href="classxn_1_1_player.html">xn::Player</a> node through which playback can be controlled, e.g., seeking and setting playback speed. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordflow">if</span> (argc &gt; 1)
                {
                    nRetVal = g_Context.<a class="code" href="classxn_1_1_context.html#adfc68c424c840a788d0903e20a95e541" title="Builds the context&#39;s general software environment.">Init</a>();
                    CHECK_RC(nRetVal, <span class="stringliteral">&quot;Init&quot;</span>);
                    nRetVal = g_Context.<a class="code" href="classxn_1_1_context.html#a3589979f63d5b9ddea49b71dcdf9fc5a" title="Recreates a production graph from a recorded ONI file and then replays the data generation exactly as...">OpenFileRecording</a>(argv[1], g_Player);
                    
                    <span class="comment">// ... code for testing &amp; printing status - see complete program </span>
                }
</pre></div><p><b>Production graph initialized from standard XML file:</b> In the following code block, g_Context.<a class="el" href="classxn_1_1_context.html#aa0f2dff24c434ed56b44332456ea9502">InitFromXmlFile()</a> initializes the context and loads the script file to build a production graph. SAMPLE_XML_PATH is the path to the XML file, <code>g_scriptNode</code> is the <a class="el" href="classxn_1_1_script_node.html">xn::ScriptNode</a> object as described earlier, and the <code>errors</code> object returns a list of any errors that occurred. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordflow">else</span>
                {
                    <a class="code" href="classxn_1_1_enumeration_errors.html">xn::EnumerationErrors</a> errors;
                    nRetVal = g_Context.<a class="code" href="classxn_1_1_context.html#aa0f2dff24c434ed56b44332456ea9502" title="Shorthand combination of two other initialization methods - Init() and then RunXmlScriptFromFile() - ...">InitFromXmlFile</a>(SAMPLE_XML_PATH, g_scriptNode, &amp;errors);
                    
                    <span class="comment">// ... code for testing &amp; printing status - see complete program </span>
                }
</pre></div><h3><a class="anchor" id="utcpp_get_nodes_from_prodgrph"></a>
Gets Nodes from Production Graph</h3>
<p>In the following code, the <a class="el" href="classxn_1_1_context.html#a48450b0fde8c947c8ba7683a4f882308">FindExistingNode()</a> call gets a reference to production nodes in the production graph. In this example, the application passes the g_depth parameter to get a reference to a <a class="el" href="classxn_1_1_depth_generator.html">DepthGenerator node</a> so that it can work with it. Then the same for a <a class="el" href="classxn_1_1_user_generator.html">UserGenerator node</a>. </p>
<div class="fragment"><pre class="fragment">                nRetVal = g_Context.<a class="code" href="classxn_1_1_context.html#a48450b0fde8c947c8ba7683a4f882308" title="Searches for an existing created node of a specified type and returns a reference to it...">FindExistingNode</a>(<a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a1415a428ab99e92cebedd4fdb1fe74c6">XN_NODE_TYPE_DEPTH</a>, g_DepthGenerator);
                ...
                nRetVal = g_Context.<a class="code" href="classxn_1_1_context.html#a48450b0fde8c947c8ba7683a4f882308" title="Searches for an existing created node of a specified type and returns a reference to it...">FindExistingNode</a>(<a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52ac93391e720c5a61b844cdee1ebc86ec7">XN_NODE_TYPE_USER</a>, g_UserGenerator);
                ...
</pre></div><h3><a class="anchor" id="utcpp_init_event_hndlrs"></a>
Initialize Event Handlers</h3>
<p>The following code blocks initialize and register event handlers for the UserGenerator node and its <a class="el" href="classxn_1_1_skeleton_capability.html">xn::SkeletonCapability</a> "skeleton capability". A skeleton capability provides <b>Skeleton</b> functionality to a <a class="el" href="classxn_1_1_user_generator.html">xn::UserGenerator</a> node. First the application checks that the node supports skeleton capability. </p>
<div class="fragment"><pre class="fragment">                <a class="code" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a> hUserCallbacks, hCalibrationStart, hCalibrationComplete, hPoseDetected, hCalibrationInProgress, hPoseInProgress;
                <span class="keywordflow">if</span> (!g_UserGenerator.<a class="code" href="classxn_1_1_production_node.html#a26574447d96527d1a9d79994e550037f" title="Returns whether a production node supports a specific capability.">IsCapabilitySupported</a>(<a class="code" href="_xn_types_8h.html#a62ac1922557ef6246bec2f2b706b129f">XN_CAPABILITY_SKELETON</a>))
                {
                    printf(<span class="stringliteral">&quot;Supplied user generator doesn&#39;t support skeleton\n&quot;</span>);
                    <span class="keywordflow">return</span> 1;
                }               
</pre></div><p>To be able to track a user's skeleton, the SkeletonCapability can execute a calibration process to measure and record the lengths of the human user's limbs. This would make it easier for OpenNI to then successfully track the human user. The calibration process can be initiated by the human user performing an agreed calibration pose.</p>
<p>Here is the code for registering the event handlers. The <a class="el" href="classxn_1_1_user_generator.html">xn::UserGenerator</a> accesses its skeleton capability by calling the <a class="el" href="classxn_1_1_user_generator.html#ac41196c59912826bb5eab3ce644cdcfb">xn::UserGenerator::GetSkeletonCap()</a> method. </p>
<div class="fragment"><pre class="fragment">                nRetVal = g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#a81c4bd31b4dd8dd25e6be52e6e692e50" title="Registers event handlers for the &#39;New User&#39; and &#39;Lost User&#39; events.">RegisterUserCallbacks</a>(User_NewUser, User_LostUser, NULL, hUserCallbacks);
                CHECK_RC(nRetVal, <span class="stringliteral">&quot;Register to user callbacks&quot;</span>);
                nRetVal = g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#a1fc75404baca1821cfc13bd1ab5b7a05" title="Registers an event handler for the &#39;Calibration Start&#39; event.">RegisterToCalibrationStart</a>(UserCalibration_CalibrationStart, NULL, hCalibrationStart);
                CHECK_RC(nRetVal, <span class="stringliteral">&quot;Register to calibration start&quot;</span>);
                nRetVal = g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#abd1ad65e0775b40d46c1787773c7fbaa" title="Registers an event handler for the &#39;Calibration Complete&#39; event.">RegisterToCalibrationComplete</a>(UserCalibration_CalibrationComplete, NULL, hCalibrationComplete);
                CHECK_RC(nRetVal, <span class="stringliteral">&quot;Register to calibration complete&quot;</span>);
</pre></div><p>The application then checks if the skeleton capability requires a pose detection in order to execute a calibration. If so, the application will have to get a <a class="el" href="classxn_1_1_pose_detection_capability.html">xn::PoseDetectionCapability</a> object. The code then registers to a 'Pose Detected' event. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordflow">if</span> (g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#a69ff7c65f2afb5ab2e26f31e90540c17" title="Returns whether a specific pose is required for calibration. This setting is applicable to all users...">NeedPoseForCalibration</a>())
                {
                    g_bNeedPose = TRUE;
                    <span class="keywordflow">if</span> (!g_UserGenerator.<a class="code" href="classxn_1_1_production_node.html#a26574447d96527d1a9d79994e550037f" title="Returns whether a production node supports a specific capability.">IsCapabilitySupported</a>(<a class="code" href="_xn_types_8h.html#abdc214267b28e16ab4e2c15800b03d62">XN_CAPABILITY_POSE_DETECTION</a>))
                    {
                        printf(<span class="stringliteral">&quot;Pose required, but not supported\n&quot;</span>);
                        <span class="keywordflow">return</span> 1;
                    }
                    nRetVal = g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#a99ffd208ee85c90dde7c6d9e13b22fd8" title="Gets a xn::PoseDetectionCapability object for accessing Pose Detection functionality.">GetPoseDetectionCap</a>().<a class="code" href="classxn_1_1_pose_detection_capability.html#a5c6b7593d6e603dfbc1be89629384cd8" title="Registers an event handler for the &#39;Pose Detected&#39; event.">RegisterToPoseDetected</a>(UserPose_PoseDetected, NULL, hPoseDetected);
                    CHECK_RC(nRetVal, <span class="stringliteral">&quot;Register to Pose Detected&quot;</span>);
                    g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#a2dd4f975348457837ebdbca87b36f691" title="Gets the name of the pose that is required for calibration. The pose and its name reside in the plug-...">GetCalibrationPose</a>(g_strPose);
                }
</pre></div><p>The following statement sets the skeleton profile. The skeleton profile specifies which joints are to be active, and which to be inactive. XN_SKEL_PROFILE_ALL means all the joints. The <a class="el" href="classxn_1_1_user_generator.html">xn::UserGenerator</a> node generates output data for the active joints only. This profile applies to all skeletons that the <a class="el" href="classxn_1_1_user_generator.html">xn::UserGenerator</a> node generates. </p>
<div class="fragment"><pre class="fragment">                g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#ab07ee49ccdb7278945af4144bb115c15" title="Sets the skeleton profile. The skeleton profile specifies which joints are to be active, and which to be inactive. The UserGenerator node generates output data for the active joints only. This profile applies to all skeletons that the UserGenerator node generates.">SetSkeletonProfile</a>(<a class="code" href="_xn_types_8h.html#a294999eabe6eeab319a61d3d0093b174a693e6a159f153e47edc3a6b4a1619949">XN_SKEL_PROFILE_ALL</a>);   
</pre></div><p>The following statements register to event handlers that report on the progress of detecting a pose and the whole calibration process. </p>
<div class="fragment"><pre class="fragment">                nRetVal = g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#a8181885d362bf59d8d99871e45ed1652" title="Registers an event handler for the &#39;Calibration In Progress&#39; event.">RegisterToCalibrationInProgress</a>(MyCalibrationInProgress, NULL, hCalibrationInProgress);
                CHECK_RC(nRetVal, <span class="stringliteral">&quot;Register to calibration in progress&quot;</span>);

                nRetVal = g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#a99ffd208ee85c90dde7c6d9e13b22fd8" title="Gets a xn::PoseDetectionCapability object for accessing Pose Detection functionality.">GetPoseDetectionCap</a>().<a class="code" href="classxn_1_1_pose_detection_capability.html#a17e3cdf28e132f66379cb4a99a9b6ffe" title="Registers an event handler for the &#39;Pose In Progress&#39; event.">RegisterToPoseInProgress</a>(MyPoseInProgress, NULL, hPoseInProgress);
                CHECK_RC(nRetVal, <span class="stringliteral">&quot;Register to pose in progress&quot;</span>);
</pre></div><p>The following statement enters all nodes in the production graph into 'Generating state'. (In this sample application, this includes at least DepthGenerator and UserGenerator.)In this state the node generates new frames. After the application has called this method it calls one of the WaitXUpdateAll methods, e.g., <a class="el" href="classxn_1_1_context.html#a17fab043d7b6d60728511527a1d5c090">WaitAnyUpdateAll()</a>, to update all generator nodes in the context to their latest available data, first waiting for any of the nodes to have new data available. The application can then get the data (for example, using a metadata GetData() method). </p>
<div class="fragment"><pre class="fragment">                nRetVal = g_Context.<a class="code" href="classxn_1_1_context.html#affa5173b7c32b98d344ab2c8634f2cb7" title="Ensures all created generator nodes are generating data.">StartGeneratingAll</a>();
                CHECK_RC(nRetVal, <span class="stringliteral">&quot;StartGenerating&quot;</span>);
</pre></div><p>Here there is a block of statements that are not OpenNI specific.</p>
<p>The following statement destroys all the nodes, releasing their memory. </p>
<div class="fragment"><pre class="fragment">                CleanupExit();          
</pre></div><p><b>FILE NAME: SceneDrawer.cpp</b></p>
<h2><a class="anchor" id="ut_scenedrawer_cpp_inc"></a>
Includes</h2>
<div class="fragment"><pre class="fragment"><span class="preprocessor">            #include &quot;SceneDrawer.h&quot;</span>
            ...
            ...
            #include &lt;map&gt;
</pre></div><h2><a class="anchor" id="ut_evhndlr_calib_in_prgrs"></a>
MyCalibrationInProgress() - 'Calibration In Progress' event handler</h2>
<p>This event handler - shown below - stores the most recent state of calibration progress, in order to show it as a label later on.</p>
<div class="fragment"><pre class="fragment">            std::map&lt;XnUInt32, std::pair&lt;XnCalibrationStatus, XnPoseDetectionStatus&gt; &gt; m_Errors;
            <span class="keywordtype">void</span> XN_CALLBACK_TYPE MyCalibrationInProgress(<a class="code" href="classxn_1_1_skeleton_capability.html">xn::SkeletonCapability</a>&amp; capability, <a class="code" href="_xn_types_8h.html#a83a03695bbf1ac00ac01d39ad21f01aa">XnUserID</a> <span class="keywordtype">id</span>, <a class="code" href="_xn_types_8h.html#ac58d2e4f6ca6abf9d55cdd9377449a77">XnCalibrationStatus</a> calibrationError, <span class="keywordtype">void</span>* pCookie)
            {
                m_Errors[id].first = calibrationError;
            }
</pre></div><h2><a class="anchor" id="ut_evhndlr_calib_in_prgrs"></a>
MyCalibrationInProgress() - 'Calibration In Progress' event handler</h2>
<p>This event handler - shown below - stores the most recent state of pose progress, in order to show it as a label later on. </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">void</span> XN_CALLBACK_TYPE MyPoseInProgress(<a class="code" href="classxn_1_1_pose_detection_capability.html">xn::PoseDetectionCapability</a>&amp; capability, <span class="keyword">const</span> XnChar* strPose, <a class="code" href="_xn_types_8h.html#a83a03695bbf1ac00ac01d39ad21f01aa">XnUserID</a> <span class="keywordtype">id</span>, <a class="code" href="_xn_types_8h.html#a2cbbffcf27ec4330430bbf0b998ae0b8">XnPoseDetectionStatus</a> poseError, <span class="keywordtype">void</span>* pCookie)
            {
                m_Errors[id].second = poseError;
            }
</pre></div><h2><a class="anchor" id="ut_hist_dec"></a>
Histogram Declarations</h2>
<p><code> g_pDepthHist[]</code> is an array with MAX_DEPTH entries (10,000 at the time of writing), one entry for each depth value that the sensor can output. This array is used for the histogram feature in the <code>DrawDepthMap()</code> function later in this file.</p>
<p>Each entry of the array is a counter for the corresponding depth value.</p>
<p><code>Histogram[] </code> is used in the DrawDepthMap() function later in this file. As the first stage of processing, DrawDepthMap() builds the histogram by scanning the depth map. For each depth pixel, DrawDepthMap() inspects the depth value, and for that value's entry in the array, it increments its counter by 1. The DrawDepthMap() function then performs further processing, as described later in the description for that function. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">            #define MAX_DEPTH 10000</span>
<span class="preprocessor">            float g_pDepthHist[MAX_DEPTH];</span>
</pre></div><h2><a class="anchor" id="ut_getClosestPowerOfTwo"></a>
getClosestPowerOfTwo() function</h2>
<p>There are no OpenNI-specific declarations in this routine.</p>
<h2><a class="anchor" id="ut_initTexture"></a>
initTexture() function</h2>
<p>There are no OpenNI-specific declarations in this routine.</p>
<h2><a class="anchor" id="ut_DrawRectangle"></a>
DrawRectangle() function</h2>
<p>There are no OpenNI-specific declarations in this routine.</p>
<h2><a class="anchor" id="ut_DrawTexture"></a>
DrawTexture() function</h2>
<p>There are no OpenNI-specific declarations in this routine.</p>
<h2><a class="anchor" id="ut_glPrintString"></a>
glPrintString() function</h2>
<p>There are no OpenNI-specific declarations in this routine.</p>
<h2><a class="anchor" id="ut_DrawLimb"></a>
DrawLimb() function</h2>
<p>This function draws a limb of the avatar representation of a human user by drawing a line between two OpenNI joints, of type <a class="el" href="_xn_types_8h.html#a7713dc7b4e1415ffe6c835c5979d65f4">xn::XnSkeletonJoint</a>, passed as parameters to this function. The two joints are meaningful points that represent human's body joints. </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">void</span> DrawLimb(<a class="code" href="_xn_types_8h.html#a83a03695bbf1ac00ac01d39ad21f01aa">XnUserID</a> player, <a class="code" href="_xn_types_8h.html#ac025301dbcbd9a91e532fa3d8991361d">XnSkeletonJoint</a> eJoint1, <a class="code" href="_xn_types_8h.html#ac025301dbcbd9a91e532fa3d8991361d">XnSkeletonJoint</a> eJoint2)
            {
                ...
            }
</pre></div><p>The human user, <code>player</code>, is specified by an integer <a class="el" href="_xn_types_8h.html#a83a03695bbf1ac00ac01d39ad21f01aa">XnUserID</a> parameter. The two OpenNI joints <a class="el" href="_xn_types_8h.html#a7713dc7b4e1415ffe6c835c5979d65f4">xn::XnSkeletonJoint</a> points are enum indicators, e.g., <a class="el" href="_xn_types_8h.html#ac025301dbcbd9a91e532fa3d8991361da972cc982697178260490313c11fc5768">XN_SKEL_HEAD</a>.</p>
<p>The statements of this function are explained below.</p>
<p>The function verifies that the user is being tracked by calling the <a class="el" href="classxn_1_1_skeleton_capability.html#a3d377a980e3c34cc12fd5354ceda89f2">IsTracking()</a> method. </p>
<div class="fragment"><pre class="fragment">            <span class="keywordflow">if</span> (!g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#a3d377a980e3c34cc12fd5354ceda89f2" title="Returns whether a user is currently being tracked.">IsTracking</a>(player))
            {
                printf(<span class="stringliteral">&quot;not tracked!\n&quot;</span>);
                <span class="keywordflow">return</span>;
            }
</pre></div><p>The following code block obtains the <a class="el" href="_xn_types_8h.html#a69cf000072ccb570b587429627bc484a">X-Y-Z</a> locations of the two joints. </p>
<div class="fragment"><pre class="fragment">            <a class="code" href="_xn_types_8h.html#a69cf000072ccb570b587429627bc484a">xn::XnSkeletonJointPosition</a> joint1, joint2;             g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#ace0584aa486fc94580003f658a88466c" title="Gets the position of one of the skeleton joints in the most recently generated user data...">GetSkeletonJointPosition</a>(player, eJoint1, joint1);
            g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#ace0584aa486fc94580003f658a88466c" title="Gets the position of one of the skeleton joints in the most recently generated user data...">GetSkeletonJointPosition</a>(player, eJoint2, joint2);
</pre></div><p>The following code block draws the avatar's limb by drawing a line between the two adjacent points. It uses the locations <code>joint1 </code> and <code> joint 2</code> obtained above.</p>
<p>The <a class="el" href="_xn_types_8h.html#a69cf000072ccb570b587429627bc484a">xn::XnSkeletonJointPosition</a> coordinates are real-world coordinates, so the <a class="el" href="classxn_1_1_depth_generator.html#a70cda9f296d0ac90088cfafc34e9edd2">convertRealWorldToProjective()</a> is used to convert the real world coordinates to projective coordinates for the purpose of drawing them on a 2D texture. </p>
<div class="fragment"><pre class="fragment">            <a class="code" href="struct_xn_vector3_d.html">XnPoint3D</a> pt[2];
            pt[0] = joint1.position;
            pt[1] = joint2.position;

            g_DepthGenerator.<a class="code" href="classxn_1_1_depth_generator.html#a70cda9f296d0ac90088cfafc34e9edd2" title="Converts a list of points from real world coordinates to projective coordinates.">ConvertRealWorldToProjective</a>(2, pt, pt);           
</pre></div><p>The rest of the code in this function draws the line on the graphic display. This code is not OpenNI specific.</p>
<h2><a class="anchor" id="utcpp_get_calibration_error_string"></a>
GetCalibrationErrorString() function</h2>
<p>This function converts an <a class="el" href="_xn_types_8h.html#a18987b762f972ed41e06d007202bb85b">xn::XnCalibrationStatus</a> type to a string. This is shown in the code block below, with example cases. </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">const</span> XnChar* GetCalibrationErrorString(<a class="code" href="_xn_types_8h.html#ac58d2e4f6ca6abf9d55cdd9377449a77">XnCalibrationStatus</a> error)
            {
                <span class="keywordflow">switch</span> (error)
                {
                <span class="keywordflow">case</span> <a class="code" href="_xn_types_8h.html#ac58d2e4f6ca6abf9d55cdd9377449a77a7e48dedb8aaa2619f73f52647681d9e2">XN_CALIBRATION_STATUS_OK</a>:
                    <span class="keywordflow">return</span> <span class="stringliteral">&quot;OK&quot;</span>;
                <span class="keywordflow">case</span> <a class="code" href="_xn_types_8h.html#ac58d2e4f6ca6abf9d55cdd9377449a77a80c995e1913c5cb953134611f4291897">XN_CALIBRATION_STATUS_NO_USER</a>:
                    <span class="keywordflow">return</span> <span class="stringliteral">&quot;NoUser&quot;</span>;
                <span class="keywordflow">case</span> <a class="code" href="_xn_types_8h.html#ac58d2e4f6ca6abf9d55cdd9377449a77a9acab7d44f7dd12ebcb1752bb2bcd556">XN_CALIBRATION_STATUS_ARM</a>:
                    <span class="keywordflow">return</span> <span class="stringliteral">&quot;Arm&quot;</span>;
                <span class="keywordflow">case</span> <a class="code" href="_xn_types_8h.html#ac58d2e4f6ca6abf9d55cdd9377449a77a108750d9d46dd22ea11bdbc036cc9aa7">XN_CALIBRATION_STATUS_LEG</a>:
                    <span class="keywordflow">return</span> <span class="stringliteral">&quot;Leg&quot;</span>;       
                    
                ...
            }
</pre></div><h2><a class="anchor" id="utcpp_get_pose_error_string"></a>
GetPoseErrorString() function</h2>
<p>This function converts an <a class="el" href="_xn_types_8h.html#acd74aa1399f2db50c7b4774ea93c1573">xn::XnPoseDetectionStatus</a> type to a string. This is shown in the code block below, with example cases. </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">const</span> XnChar* GetPoseErrorString(<a class="code" href="_xn_types_8h.html#a2cbbffcf27ec4330430bbf0b998ae0b8">XnPoseDetectionStatus</a> error)
            {       
                <span class="keywordflow">switch</span> (error)
                {
                <span class="keywordflow">case</span> <a class="code" href="_xn_types_8h.html#a2cbbffcf27ec4330430bbf0b998ae0b8a13c583ef430111dc83bb493f7e4fb850">XN_POSE_DETECTION_STATUS_OK</a>:
                    <span class="keywordflow">return</span> <span class="stringliteral">&quot;OK&quot;</span>;
                <span class="keywordflow">case</span> <a class="code" href="_xn_types_8h.html#a2cbbffcf27ec4330430bbf0b998ae0b8af5df3e36670e51abb1f337745a12452d">XN_POSE_DETECTION_STATUS_NO_USER</a>:
                    <span class="keywordflow">return</span> <span class="stringliteral">&quot;NoUser&quot;</span>;
                <span class="keywordflow">case</span> <a class="code" href="_xn_types_8h.html#a2cbbffcf27ec4330430bbf0b998ae0b8a7d94841658e606d6cab13673778be771">XN_POSE_DETECTION_STATUS_TOP_FOV</a>:
                    <span class="keywordflow">return</span> <span class="stringliteral">&quot;Top FOV&quot;</span>;       
                ...
            }
</pre></div><h2><a class="anchor" id="utcpp_fndrawdepthmap"></a>
DrawDepthMap() function</h2>
<p>The DrawDepthMap() function is located on the <code>SceneDrawer.cpp</code> file. In this function, both the frame objects -- <code>dmd</code> and <code>smd</code> -- are accessed to get their data. The same method is used, <code>Data()</code>, which is the standard metadata method for returning a pointer to a frame object's data. </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">const</span> <a class="code" href="_xn_types_8h.html#ad55e431b82556504d5c1c00d153156c9">XnDepthPixel</a>* pDepth = dmd.<a class="code" href="classxn_1_1_depth_meta_data.html#a31c9bda08462e89c9962268f3bf194fe" title="Returns the depth map.">Data</a>();
            <span class="keyword">const</span> <a class="code" href="_xn_types_8h.html#aec5b09539e1c361fc5d6bc534447a610">XnLabel</a>* pLabels = smd.Data();            
</pre></div><p>The main user processing loop of this function gets each user in turn and displays it. The following declarations support this processing:</p>
<h3><a class="anchor" id="utcpp_ddm_calc_hist"></a>
Calculate the Accumulative Histogram</h3>
<p>The following initializations are for calculating the accumulative histogram.</p>
<p>The following statement accesses the Map Output mode to get the DepthGenerator's map dimensions and pixel color format. <a class="el" href="classxn_1_1_map.html#addae31672b376dc4a79d8856b831ab1b">XRes</a> and <a class="el" href="classxn_1_1_map.html#a12df2e51951f42f4265e27e14d8d412b">YRes</a> get the frame X an Y resolutions of the most recently generated data. X and is the number of columns and rows, respectively, in the frame after any required cropping has been applied. See <a class="el" href="conc_map_wrapper_classes.html">Map Wrapper Classes</a> for more information.<br/>
 </p>
<div class="fragment"><pre class="fragment">                XnUInt16 g_nXRes = dmd.<a class="code" href="classxn_1_1_map_meta_data.html#a597e11801d9305dfa4c1f78ec249bf0a">XRes</a>();
                XnUInt16 g_nYRes = dmd.<a class="code" href="classxn_1_1_map_meta_data.html#a4daff8222744af42afbb8114600967f9">YRes</a>();
</pre></div><p>The following code block calculates the accumulative histogram.</p>
<p>The following statement initializes the histogram array. This array is a key part of this sample program. (This code is not OpenNI specific.) The histogram feature of this sample program creates a gradient of the scene's depth scene, from dark (far away) to light (close), regardless of the color.</p>
<p>The first loop, a nested for- loop just counts the frequency of each depth value. </p>
<div class="fragment"><pre class="fragment">                memset(g_pDepthHist, 0, MAX_DEPTH*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
                <span class="keywordflow">for</span> (nY=0; nY&lt;g_nYRes; nY++)
                {
                    <span class="keywordflow">for</span> (nX=0; nX&lt;g_nXRes; nX++)
                    {
                        nValue = *pDepth;

                        <span class="keywordflow">if</span> (nValue != 0)
                        {
                            g_pDepthHist[nValue]++;
                            nNumberOfPoints++;
                        }

                        pDepth++;
                    }
                }
</pre></div><p>The following loop converts the frequency count into an accumulative count. Starting from the first entry this loop calculates a new value for each entry's counter as the sum of itself (<code>[n]</code>) and the value of the previous counter (<code>[n-1]</code>). </p>
<div class="fragment"><pre class="fragment">                <span class="keywordflow">for</span> (nIndex=1; nIndex&lt;MAX_DEPTH; nIndex++)
                {
                    g_pDepthHist[nIndex] += g_pDepthHist[nIndex-1];
                }       
</pre></div><p>The following code block completes the histogram. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordflow">if</span> (nNumberOfPoints)
                {
                    <span class="keywordflow">for</span> (nIndex=1; nIndex&lt;MAX_DEPTH; nIndex++)
                    {
                        g_pDepthHist[nIndex] = (<span class="keywordtype">unsigned</span> int)(256 * (1.0f - (g_pDepthHist[nIndex] / nNumberOfPoints)));
                    }
                }       
</pre></div><h3><a class="anchor" id="utcpp_ddm_set_color"></a>
Sets Color according to User</h3>
<p>This code block loops over all the depth values, checking to which user each pixel belongs, and sets the color in the texture according to the user (white for background, others for specific users) and the distance (hue). </p>
<div class="fragment"><pre class="fragment">                    pDepth = dmd.<a class="code" href="classxn_1_1_depth_meta_data.html#a31c9bda08462e89c9962268f3bf194fe" title="Returns the depth map.">Data</a>();
                    <span class="keywordflow">if</span> (g_bDrawPixels)
                    {
                        XnUInt32 nIndex = 0;
                        <span class="comment">// Prepare the texture map</span>
                        <span class="keywordflow">for</span> (nY=0; nY&lt;g_nYRes; nY++)
                        {
                            <span class="keywordflow">for</span> (nX=0; nX &lt; g_nXRes; nX++, nIndex++)
                            {

                                pDestImage[0] = 0;
                                pDestImage[1] = 0;
                                pDestImage[2] = 0;
                                <span class="keywordflow">if</span> (g_bDrawBackground || *pLabels != 0)
                                {
                                    nValue = *pDepth;
                                    <a class="code" href="_xn_types_8h.html#aec5b09539e1c361fc5d6bc534447a610">XnLabel</a> label = *pLabels;
                                    XnUInt32 nColorID = label % nColors;
                                    <span class="keywordflow">if</span> (label == 0)
                                    {
                                        nColorID = nColors;
                                    }

                                    <span class="keywordflow">if</span> (nValue != 0)
                                    {
                                        nHistValue = g_pDepthHist[nValue];

                                        pDestImage[0] = nHistValue * Colors[nColorID][0]; 
                                        pDestImage[1] = nHistValue * Colors[nColorID][1];
                                        pDestImage[2] = nHistValue * Colors[nColorID][2];
                                    }
                                }

                                pDepth++;
                                pLabels++;
                                pDestImage+=3;
                            }

                            pDestImage += (texWidth - g_nXRes) *3;
                        }
                    }
                    <span class="keywordflow">else</span>
                    {
                        <a class="code" href="_xn_o_s_memory_8h.html#ad0f2ea99cefaa47ac9750f8c434097de">xnOSMemSet</a>(pDepthTexBuf, 0, 3*2*g_nXRes*g_nYRes);
                    }
</pre></div><h3><a class="anchor" id="utcpp_ddm_loop"></a>
Main Loop for Processing Users (DrawDepthMap())</h3>
<p>The main loop of this function for processing users gets each user in turn and displays it. </p>
<div class="fragment"><pre class="fragment">                    <span class="keywordtype">char</span> strLabel[50] = <span class="stringliteral">&quot;&quot;</span>;
                    <a class="code" href="_xn_types_8h.html#a83a03695bbf1ac00ac01d39ad21f01aa">XnUserID</a> aUsers[15];
                    XnUInt16 nUsers = 15;
                    g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#a174c171f0094266c7ee51a0eb1844e86" title="Gets an array of user IDs of all the recognized users in the scene at the current time...">GetUsers</a>(aUsers, nUsers);
                    
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nUsers; ++i)
                        ...
                        ...
                        ...
                    }
</pre></div><p>The following code block gets a user's center of mass (CoM). This is a single point for representing the user. The CoM is a useful point to represent the user. When you don't have any other reference point (e.g., you don't have the position of a specific joint, or of the head, or any other such point), this is an adequate point with which to start to represent the user. This application uses the CoM as the position at which it writes the user's label. The label comprises its user ID and its current state.</p>
<div class="fragment"><pre class="fragment">                    <a class="code" href="struct_xn_vector3_d.html">XnPoint3D</a> com;
                    g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#a451c8a197374b567e62622f5edcb1670" title="Gets the position of a user&#39;s center of mass. This is the single point for representing the user...">GetCoM</a>(aUsers[i], com);
                    g_DepthGenerator.<a class="code" href="classxn_1_1_depth_generator.html#a70cda9f296d0ac90088cfafc34e9edd2" title="Converts a list of points from real world coordinates to projective coordinates.">ConvertRealWorldToProjective</a>(1, &amp;com, &amp;com);
</pre></div><p>The following statements access the status of each user to display it above each corresponding user image that is displayed on the output display device.</p>
<p>The following statement adds the user's ID to the label, to be displayed on the com of the user the name of the user. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordflow">if</span> (!g_bPrintState)
                    sprintf(strLabel, <span class="stringliteral">&quot;%d&quot;</span>, aUsers[i]);
</pre></div><p>The following statement gets whether the user's skeleton is being tracked. </p>
<div class="fragment"><pre class="fragment">                    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#a3d377a980e3c34cc12fd5354ceda89f2" title="Returns whether a user is currently being tracked.">IsTracking</a>(aUsers[i]))
                        sprintf(strLabel, <span class="stringliteral">&quot;%d - Tracking&quot;</span>, aUsers[i]);
</pre></div><p>The following statement gets whether the user's skeleton is still in the middle of being being calibrated. This means that tracking has not yet started. </p>
<div class="fragment"><pre class="fragment">                    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#aa86d9246c806eacb6fd626290d4cf0e7" title="Returns whether a user is being calibrated right now. see Calibration.">IsCalibrating</a>(aUsers[i]))
                        sprintf(strLabel, <span class="stringliteral">&quot;%d - Calibrating [%s]&quot;</span>, aUsers[i], GetCalibrationErrorString(m_Errors[aUsers[i]].first));
</pre></div><p>The following 'else-other' statement displays that the application is still looking for the user to start a pose in order to start calibration and the current status of the pose detection. Values are: OK, NO_USER, TOP_FOV, SIDE_FOV, ERROR </p>
<div class="fragment"><pre class="fragment">                    <span class="keywordflow">else</span> {
                        sprintf(strLabel, <span class="stringliteral">&quot;%d - Looking for pose [%s]&quot;</span>, aUsers[i], GetPoseErrorString(m_Errors[aUsers[i]].second)); }
</pre></div><p>Finally, this application demonstrates an example method, <code>DrawLimb()</code> , for drawing limbs of all tracked users on a graphical display. A limb is the graphical representation of the human user's arm or leg for example. This method works by taking two parameters that specify a start joint and an end joint for drawing a vector that represents the limb. For example, a 'head' start joint to a 'neck' end joint draws the neck; 'neck' to 'left shoulder' draws the 'left shoulder bridge'.</p>
<p>The call looks something like this: </p>
<div class="fragment"><pre class="fragment">                    DrawLimb(aUsers[i], <a class="code" href="_xn_types_8h.html#ac025301dbcbd9a91e532fa3d8991361da972cc982697178260490313c11fc5768">XN_SKEL_HEAD</a>, <a class="code" href="_xn_types_8h.html#ac025301dbcbd9a91e532fa3d8991361dabb6c3dc5032aacc6d6c4983d5d510f7d">XN_SKEL_NECK</a>);
</pre></div> </div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue Nov 12 2013 16:35:27 for OpenNI 1.5.7 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
