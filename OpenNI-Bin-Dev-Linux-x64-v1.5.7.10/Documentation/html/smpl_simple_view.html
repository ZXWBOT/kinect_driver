<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenNI 1.5.7: NiSimpleViewer.cpp - sample program</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="OpenNILogo.bmp"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenNI 1.5.7
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">OpenNI Overview</a>      </li>
      <li class="navelem"><a class="el" href="smpls_n_guides.html">Samples and Guides</a>      </li>
      <li class="navelem"><a class="el" href="smpls.html">Sample Programs for the OpenNI API</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">NiSimpleViewer.cpp - sample program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Source file:</b> Click the following link to view the source code file:</p>
<ul>
<li>NiSimpleViewer.cpp</li>
</ul>
<p>This section describes the SimpleViewer sample program. This sample program uses a DepthGenerator node and ImageGenerator node to build an accumulative histogram from depth values.</p>
<h2><a class="anchor" id="sv_glb_dcl_blk"></a>
Global Declaration Block</h2>
<p>The following definition is for the path to an OpenNI XML script file for inputting and building a stored production graph. The <em>production graph</em> is a network of <em>production nodes</em> and is the principal OpenNI object model. The identifies blobs as hands or human users. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">            #define SAMPLE_XML_PATH &quot;../../../../Data/SamplesConfig.xml&quot;</span>
</pre></div><p>The following declares the array for the histogram array that is a key part of this sample program. (This is not OpenNI specific.) </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">float</span> g_pDepthHist[MAX_DEPTH];
</pre></div><p>The following declaration block declares the OpenNI objects required for building the OpenNI production graph. </p>
<div class="fragment"><pre class="fragment">            Context g_context;
            ScriptNode g_scriptNode;
            DepthGenerator g_depth;
            ImageGenerator g_image;
            DepthMetaData g_depthMD;
            ImageMetaData g_imageMD;
</pre></div><p>Each of these declarations is described separately in the following paragraphs.</p>
<p>A <a class="el" href="classxn_1_1_context.html">Context</a> object is a workspace in which the application builds an OpenNI production graph.</p>
<p>The <a class="el" href="classxn_1_1_script_node.html">ScriptNode</a> object loads an XML script from a file or string, and then runs the XML script to build a production graph.</p>
<p>The <a class="el" href="classxn_1_1_depth_generator.html">DepthGenerator</a> node generates a depth map. Each map pixel value represents a distance from the sensor.</p>
<p>The <a class="el" href="classxn_1_1_image_generator.html">ImageGenerator</a> node generates color image maps of various formats, such as the RGB24 image format. Call its <a class="el" href="classxn_1_1_image_generator.html#a1297b84dcc77a2e81300d5fa17b3efec">SetPixelFormat()</a> method to set the image format to be generated.</p>
<p>The <a class="el" href="classxn_1_1_depth_meta_data.html">DepthMetaData</a> object provides a <a class="el" href="glossary.html#glos_frame_object">frame object</a> for the <a class="el" href="classxn_1_1_depth_generator.html">xn::DepthGenerator</a> node. A <a class="el" href="glossary.html#dict_gen_node">generator node's</a> <a class="el" href="glossary.html#glos_frame_object">frame object</a> contains a generated data frame and all its associated properties. This frame object, comprising the data frame and its properties, is accessible through the node's metadata object.</p>
<p>The <a class="el" href="classxn_1_1_image_meta_data.html">ImageMetaData</a> object provides a <a class="el" href="glossary.html#glos_frame_object">frame object</a> for the <a class="el" href="classxn_1_1_image_generator.html">xn::ImageGenerator</a> node. This metadata object is associated with an ImageGenerator node in the same way as the DepthMetaData object is associated with a DepthGenerator node.</p>
<h2><a class="anchor" id="sv_func_main"></a>
Main Program</h2>
<p>The declarations at the top of the main program collect and report status and errors from any of the OpenNI functions. </p>
<div class="fragment"><pre class="fragment">            <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> rc;
            EnumerationErrors errors;
</pre></div><h3><a class="anchor" id="sv_scrpt_sets_up_pg"></a>
Use Script to Set up a Context and Production Graph</h3>
<p>The <a class="el" href="classxn_1_1_context.html#aa0f2dff24c434ed56b44332456ea9502">InitFromXmlFile()</a> method is a shorthand combination of two other initialization methods &mdash; <a class="el" href="classxn_1_1_context.html#adfc68c424c840a788d0903e20a95e541">Init()</a> and then <a class="el" href="classxn_1_1_context.html#a0145a926d2656d0f05399ed8d5f90ec6">RunXmlScriptFromFile()</a> &mdash; which initializes the context object and then creates a production graph from an XML file. The XML script file describes all the nodes you want to create. For each node description in the XML file, this method creates a node in the production graph. </p>
<div class="fragment"><pre class="fragment">                rc = g_context.InitFromXmlFile(SAMPLE_XML_PATH, g_scriptNode, &amp;errors);
</pre></div><h3><a class="anchor" id="sv_ver_nodes_in_script"></a>
Verify Existence of Nodes in the Sample Script File</h3>
<p>This is verification code to check that OpenNI found at least one node definition in the script file. The program continues execution only if at least one node definition if found. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordflow">if</span> (rc == XN_STATUS_NO_NODE_PRESENT)
                {
                    XnChar strError[1024];
                    errors.ToString(strError, 1024);
                    printf(<span class="stringliteral">&quot;%s\n&quot;</span>, strError);
                    <span class="keywordflow">return</span> (rc);
                }
                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc != <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>)
                {
                    printf(<span class="stringliteral">&quot;Open failed: %s\n&quot;</span>, <a class="code" href="_xn_status_8h.html#a709a2190465f4a6d7893587e53d66798">xnGetStatusString</a>(rc));
                    <span class="keywordflow">return</span> (rc);
                }
</pre></div><h3><a class="anchor" id="sv_get_dg_node_from_pg"></a>
Get a DepthGenerator Node from the Production Graph</h3>
<p>Assuming that the above call to <a class="el" href="classxn_1_1_context.html#aa0f2dff24c434ed56b44332456ea9502">InitFromXmlFile()</a> succeeded, a production graph is then created.</p>
<p>The <a class="el" href="classxn_1_1_context.html#a48450b0fde8c947c8ba7683a4f882308">FindExistingNode()</a> method in the following code block tries to get a reference to any one of the production nodes. This call specifies XN_NODE_TYPE_DEPTH to get a reference to a <a class="el" href="classxn_1_1_depth_generator.html">DepthGenerator</a> node. A DepthGenerator node generates a depth map as an array of pixels, where each pixel is a depth value representing a distance from the sensor in millimeters. A reference to the node is returned in the depth parameter. </p>
<div class="fragment"><pre class="fragment">                rc = g_context.FindExistingNode(<a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a1415a428ab99e92cebedd4fdb1fe74c6">XN_NODE_TYPE_DEPTH</a>, g_depth);
</pre></div><p>The code block that follows the FindExistingNode() call just checks that OpenNI found a DepthGenerator node in the production graph. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordflow">if</span> (rc != <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>)
                {
                    printf(<span class="stringliteral">&quot;No depth node exists! Check your XML.&quot;</span>);
                    <span class="keywordflow">return</span> 1;
                }
</pre></div><h3><a class="anchor" id="sv_get_dg_node_from_pg"></a>
Get a DepthGenerator Node from the Production Graph</h3>
<p>The following code is similar to the previous code block, but this time the FindExistingNode() method call gets a reference to an <a class="el" href="classxn_1_1_image_generator.html">ImageGenerator</a> node. Assuming that an ImageGenerator node was found, a reference to it is returned in the g_image parameter. </p>
<div class="fragment"><pre class="fragment">                rc = g_context.FindExistingNode(<a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a6c93c4744f518c307c7c60f3b86937e4">XN_NODE_TYPE_IMAGE</a>, g_image);
                <span class="keywordflow">if</span> (rc != <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>)
                {
                    printf(<span class="stringliteral">&quot;No image node exists! Check your XML.&quot;</span>);
                    <span class="keywordflow">return</span> 1;
                }
</pre></div><h3><a class="anchor" id="sv_get_dg_data"></a>
Get the DepthGenerator's Data</h3>
<p>The following statement gets the latest generated depth <a class="el" href="glossary.html#glos_frame_object">frame object</a>, saving it as a metadata object. </p>
<div class="fragment"><pre class="fragment">                g_depth.GetMetaData(g_depthMD);
</pre></div><h3><a class="anchor" id="sv_get_dg_latest"></a>
Get the ImageGenerator's Latest Data</h3>
<p>This works the asme as for the DepthGenerator as above. </p>
<div class="fragment"><pre class="fragment">                g_image.GetMetaData(g_imageMD);
</pre></div><h3><a class="anchor" id="sv_chk_unsprted_mode"></a>
Checking for Unsupported Mode or Format</h3>
<p>The following code block checks for Hybrid mode requirement. Hybrid mode isn't supported in this sample. This check accesses some attributes of the frame data's associated configuration properties: FullXRes() and FullYRes() are the full frame resolution, i.e., the entire field-of-view, ignoring cropping of the FOV in the scene. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordflow">if</span> (g_imageMD.FullXRes() != g_depthMD.FullXRes() || g_imageMD.FullYRes() != g_depthMD.FullYRes())
                {
                    printf (<span class="stringliteral">&quot;The device depth and image resolution must be equal!\n&quot;</span>);
                    <span class="keywordflow">return</span> 1;
                }
</pre></div><p>The following code block checks that the selected pixel format is RGB24. Other formats are not supported. if (g_imageMD.PixelFormat() != XN_PIXEL_FORMAT_RGB24) </p>
<div class="fragment"><pre class="fragment">                <span class="keywordflow">if</span> (g_imageMD.PixelFormat() != <a class="code" href="_xn_types_8h.html#a1353b63052b435e150ca0f652539b431afc4300ee27b00fd2bfd6c9a581110543">XN_PIXEL_FORMAT_RGB24</a>)
                {
                    printf(<span class="stringliteral">&quot;The device image format must be RGB24\n&quot;</span>);
                    <span class="keywordflow">return</span> 1;
                }
</pre></div><h3><a class="anchor" id="sv_init_texture_map"></a>
Initializing the Texture Map</h3>
<p>The dimensions of the Texture Map buffer are calculated by rounding the full frame resolution of the DepthGenerator data frame. full frame resolution is accessed through <a class="el" href="classxn_1_1_map_meta_data.html#aab0c5091d10a2bf27e2e6e6204888531">xn::MapMetaData::FullXRes()</a> "FullXRes()" and <a class="el" href="classxn_1_1_map_meta_data.html#ae087d7ea0aacda7854edea49b1419e4f">xn::MapMetaData::FullYRes()</a> "FullYRes()" (again, both accessed through the metadata frame object). </p>
<div class="fragment"><pre class="fragment">                g_nTexMapX = (((<span class="keywordtype">unsigned</span> short)(g_depthMD.FullXRes()-1) / 512) + 1) * 512;
                g_nTexMapY = (((<span class="keywordtype">unsigned</span> short)(g_depthMD.FullYRes()-1) / 512) + 1) * 512;
                g_pTexMap = (<a class="code" href="struct_xn_r_g_b24_pixel.html">XnRGB24Pixel</a>*)malloc(g_nTexMapX * g_nTexMapY * <span class="keyword">sizeof</span>(<a class="code" href="struct_xn_r_g_b24_pixel.html">XnRGB24Pixel</a>));
</pre></div><h2><a class="anchor" id="sv_func_glut_disp"></a>
glutDisplay()  - Display Control</h2>
<p>Significant OpenNI programming is performed inside the glutDisplay() callback.</p>
<h3><a class="anchor" id="sv_read_fos"></a>
Read the Frame Objects</h3>
<p>The following code blocks read the frame objects from the DepthGenerator and ImageGenerator nodes.</p>
<p>the <a class="el" href="classxn_1_1_context.html#a17fab043d7b6d60728511527a1d5c090">WaitAnyUpdateAll()</a> method in the following statement updates all generator nodes in the context that have new data available, first waiting for a specified node to have new data available. The application can then get the data (for example, using a metadata GetData() method). This method has a timeout. </p>
<div class="fragment"><pre class="fragment">                nRetVal = context.WaitOneUpdateAll(depth);
</pre></div><p>The following code block calls the GetMetaData() methods of each of the two generator nodes to get the nodes' frame data from the frame objects &ndash; depthMD and g_imageMD, as already explained earlier.</p>
<p>The code then calls the Data() methods of each of the frame objects to get pointers &ndash; pDepth and pImage &ndash; into their respective map buffers. All further access to the data from the DepthGenerator and ImageGenerator nodes are through these frame objects. </p>
<div class="fragment"><pre class="fragment">                g_depth.GetMetaData(g_depthMD);
                g_image.GetMetaData(g_imageMD);
                <span class="keyword">const</span> <a class="code" href="_xn_types_8h.html#ad55e431b82556504d5c1c00d153156c9">XnDepthPixel</a>* pDepth = g_depthMD.Data();
                <span class="keyword">const</span> XnUInt8* pImage = g_imageMD.Data();
</pre></div><h3><a class="anchor" id="sv_scale_images"></a>
Scale the Images</h3>
<p>The following code uses the FullXRes() to calculate the scaling factor between the depth map and the GL window. FullXRes() gets the full frame resolution, i.e., the entire field-of-view, ignoring cropping of the FOV in the scene. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nImageScale = GL_WIN_SIZE_X / g_depthMD.FullXRes();
</pre></div><h3><a class="anchor" id="sv_build_histo"></a>
Using the Depth Values to Build an Accumulative Histogram</h3>
<p>The program builds an <em>accumulative histogram</em> in order to process the maps for increasing the contrast of areas of different depths so that areas closer to the sensor are brighter than areas further away from the sensor. The accumulative histogram achieves this by separating out areas of different depth values.</p>
<p><b>Building the Initial Histogram: </b></p>
<p>The following code block builds a histogram of the depth map. It uses the depth values to build a histogram of frequency of occurrence of each depth value.</p>
<p>The <code>*pDepth</code> pointer accesses each value in the depth map's frame object. It then uses the value as an index into the <code>g_pDepthHist</code> histogram array. </p>
<div class="fragment"><pre class="fragment">            <a class="code" href="_xn_o_s_memory_8h.html#ad0f2ea99cefaa47ac9750f8c434097de">xnOSMemSet</a>(g_pDepthHist, 0, MAX_DEPTH*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));

            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nNumberOfPoints = 0;
            <span class="keywordflow">for</span> (XnUInt y = 0; y &lt; g_depthMD.YRes(); ++y)
            {
                <span class="keywordflow">for</span> (XnUInt x = 0; x &lt; g_depthMD.XRes(); ++x, ++pDepth) <span class="comment">// pDepth &#39;walks&#39; through the depth map, pixel by pixel</span>
                {
                    <span class="keywordflow">if</span> (*pDepth != 0)   <span class="comment">// *pDepth accesses the depth value of the current depth pixel in the depth map</span>
                    {                   <span class="comment">// A depth value of zero means no valid depth was obtained</span>
                        g_pDepthHist[*pDepth]++; <span class="comment">// Increments the counter of the current depth value </span>
                        nNumberOfPoints++;
                    }
                }
            }
</pre></div><p><b>Converting the histogram into a cumulative histogram: </b></p>
<p>The following processing loop converts the histogram into a cumulative histogram of frequency of occurrence of each depth value. The cumulative histogram is a histogram in which the vertical axis shows not just the counts for a single depth value, but instead -- for each depth value -- shows the counts for that depth value plus all counts for smaller depth values. The processing loop achieves this by making a running total of the counters of the depth values. Depth values whose counters reach relatively large numbers indicate blobs at those depths. The cumulative total always increases for all depth values each, faster when the depth values are encountered that represent the sides of a blob, and more slowly at a blob's peak. Thus, blobs at significantly different depths are separated out by the histogram to be at significantly different frequency levels. </p>
<div class="fragment"><pre class="fragment">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nIndex=1; nIndex&lt;MAX_DEPTH; nIndex++)
            {
                g_pDepthHist[nIndex] += g_pDepthHist[nIndex-1];
            }
</pre></div><p>Note that at this stage a larger depth value means a greater distance of a human user from the sensor; accordingly, the higher cumulative frequency levels also mean a greater distance. Since we want a greater distance to be presented by a lower brightness (darker color), and a smaller distance to be represented by a greater brightness, then later in the code this direction must be reversed.</p>
<p>The following processing loop normalizes the cumulative histogram by dividing each counter by <code>nNumberOfPoints</code>, i.e., it converts every counter to a fraction of 1.</p>
<p>This loop also reverses the direction of the histogram - as explained above. This is the term: </p>
<div class="fragment"><pre class="fragment">            (1.0f - )
</pre></div><p>So now we have got the brightness factor we need: a smaller distance (depth) is represented by a greater cumulative count for a greater brightness, and larger distance (depth) is represented by a smaller cumulative count for a lower brightness.</p>
<p>The <code>(256 * )</code> multiplier and <code>(unsigned int)</code> cast then convert the brightness from a fraction of 1 to an integer between 0 and 255, which is exactly what is needed to directly create an RGB color later in this routine. </p>
<div class="fragment"><pre class="fragment">            <span class="keywordflow">if</span> (nNumberOfPoints)
            {
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nIndex=1; nIndex&lt;MAX_DEPTH; nIndex++)
                {
                    g_pDepthHist[nIndex] = (<span class="keywordtype">unsigned</span> int)(256 * (1.0f - (g_pDepthHist[nIndex] / nNumberOfPoints)));
                }
            }
</pre></div><p>The histogram calculation has now been completed. We now have a <code>g_pDepthHist</code> array that when indexing it with a depth value returns you a brightness value that is (usually) significantly larger than the brightness value returned by indexing with a smaller depth value.</p>
<p><code>xnOSMemSet</code> is an OpenNI function that allocates and zeros. This OpenNI function calls the C++ <code>memset()</code> function. <code>g_pTexMap</code> is an area of memory used by the following code as a texture buffer for preparing a map to pass to GL for display on the monitor. </p>
<div class="fragment"><pre class="fragment">            <a class="code" href="_xn_o_s_memory_8h.html#ad0f2ea99cefaa47ac9750f8c434097de">xnOSMemSet</a>(g_pTexMap, 0, g_nTexMapX*g_nTexMapY*<span class="keyword">sizeof</span>(<a class="code" href="struct_xn_r_g_b24_pixel.html">XnRGB24Pixel</a>));
</pre></div><p><b>Preparing the Image Map and Depth Map for Output to GL: </b></p>
<p>The following two code blocks copy pixels from the OpenNI image map and depth map to the texture, <code>g_pTexMap</code>, in that order. These two code blocks declare a number of pointers that point into the <code>g_pTexMap</code> buffer.</p>
<p><em>See the diagram <a href="#NiSimpleViewer_Preparing_Maps_for_GL">"Preparing 
		the Image Map and Depth Map for Output to GL"</a></em>. This diagram clearly explains the following code blocks and the use of the pointers.</p>
<p>In the loops in the following two code blocks, <code>pTex</code> walks through the texture, <code>pImage</code> walks through the image map, and <code>pDepth</code> walks through the depth map.</p>
<p>Check if we need to draw an image frame to the texture. </p>
<div class="fragment"><pre class="fragment">            <span class="keywordflow">if</span> (g_nViewState == DISPLAY_MODE_OVERLAY ||
                g_nViewState == DISPLAY_MODE_IMAGE)
            {
                <span class="keyword">const</span> <a class="code" href="struct_xn_r_g_b24_pixel.html">XnRGB24Pixel</a>* pImageRow = g_imageMD.RGB24Data();
                <a class="code" href="struct_xn_r_g_b24_pixel.html">XnRGB24Pixel</a>* pTexRow = g_pTexMap + g_imageMD.YOffset() * g_nTexMapX;

                <span class="keywordflow">for</span> (XnUInt y = 0; y &lt; g_imageMD.YRes(); ++y)
                {
                    <span class="keyword">const</span> <a class="code" href="struct_xn_r_g_b24_pixel.html">XnRGB24Pixel</a>* pImage = pImageRow;
                    <a class="code" href="struct_xn_r_g_b24_pixel.html">XnRGB24Pixel</a>* pTex = pTexRow + g_imageMD.XOffset();

                    <span class="keywordflow">for</span> (XnUInt x = 0; x &lt; g_imageMD.XRes(); ++x, ++pImage, ++pTex)
                    {
                        *pTex = *pImage;
                    }

                    pImageRow += g_imageMD.XRes();
                    pTexRow += g_nTexMapX;
                }
            }
</pre></div><p>Check if we need to draw a depth frame to the texture. The depth value of each pixel, as converted by the accumulative histogram above, is displayed in a yellow shade. The accumulative histogram controls the brightness of the yellow color. Brighter colors represent areas closer to the hardware sensor.</p>
<p>In 'Overlay' mode (<code>g_nViewState == DISPLAY_MODE_OVERLAY)</code>, the depth pixels overwrite the image pixels inb the texture. The following code overwrites only pixels with a valid depth value <code>(*pDepth == 0)</code>. Program pixels with no valid depth value <code>(*pDepth != 0)</code> are left in their original color from the previous code block that writes out the image frame. </p>
<div class="fragment"><pre class="fragment">            <span class="keywordflow">if</span> (g_nViewState == DISPLAY_MODE_OVERLAY ||
                g_nViewState == DISPLAY_MODE_DEPTH)
            {
                <span class="keyword">const</span> <a class="code" href="_xn_types_8h.html#ad55e431b82556504d5c1c00d153156c9">XnDepthPixel</a>* pDepthRow = g_depthMD.Data();
                <a class="code" href="struct_xn_r_g_b24_pixel.html">XnRGB24Pixel</a>* pTexRow = g_pTexMap + g_depthMD.YOffset() * g_nTexMapX;

                <span class="keywordflow">for</span> (XnUInt y = 0; y &lt; g_depthMD.YRes(); ++y)
                {
                    <span class="keyword">const</span> <a class="code" href="_xn_types_8h.html#ad55e431b82556504d5c1c00d153156c9">XnDepthPixel</a>* pDepth = pDepthRow;
                    <a class="code" href="struct_xn_r_g_b24_pixel.html">XnRGB24Pixel</a>* pTex = pTexRow + g_depthMD.XOffset();

                    <span class="keywordflow">for</span> (XnUInt x = 0; x &lt; g_depthMD.XRes(); ++x, ++pDepth, ++pTex)
                    {
                        <span class="keywordflow">if</span> (*pDepth != 0)
                        {
                            <span class="keywordtype">int</span> nHistValue = g_pDepthHist[*pDepth];
                            pTex-&gt;<a class="code" href="struct_xn_r_g_b24_pixel.html#abbb04a1b5d737d90e10a5975fc90eb87">nRed</a> = nHistValue;
                            pTex-&gt;<a class="code" href="struct_xn_r_g_b24_pixel.html#a9680d1b8556966a9db7556c0131ea03f">nGreen</a> = nHistValue;
                            pTex-&gt;<a class="code" href="struct_xn_r_g_b24_pixel.html#a9bbd69f246f9ec2d143f0c2802254a8b">nBlue</a> = 0;
                        }
                    }

                    pDepthRow += g_depthMD.XRes();
                    pTexRow += g_nTexMapX;
                }
            }
</pre></div><h2><a class="anchor" id="NiSimpleViewer_Preparing_Maps_for_GL_sect"></a>
Preparing the Image Map and Depth Map for Output to GL</h2>
<p><a class="anchor" id="NiSimpleViewer_Preparing_Maps_for_GL"></a>"Preparing the Image Map and Depth Map for Output to GL".</p>
<div class="image">
<img src="NiSimpleViewer_Prep_Image_and_Depth_Maps_for_Output_to_GL.png" alt="NiSimpleViewer_Prep_Image_and_Depth_Maps_for_Output_to_GL.png"/>
</div>
 </div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue Nov 12 2013 16:35:27 for OpenNI 1.5.7 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
