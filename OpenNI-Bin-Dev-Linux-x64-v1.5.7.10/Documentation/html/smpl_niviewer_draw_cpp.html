<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenNI 1.5.7: Draw.cpp file</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="OpenNILogo.bmp"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenNI 1.5.7
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">OpenNI Overview</a>      </li>
      <li class="navelem"><a class="el" href="smpls_n_guides.html">Samples and Guides</a>      </li>
      <li class="navelem"><a class="el" href="smpls.html">Sample Programs for the OpenNI API</a>      </li>
      <li class="navelem"><a class="el" href="smpl_niviewer.html">NiViewer - sample program</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Draw.cpp file </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Source files:</b> Click the following link to view the source code file:</p>
<ul>
<li>Draw.cpp</li>
</ul>
<p>This file contains the code for displaying the frames from the OpenNI generator nodes.</p>
<h2><a class="anchor" id="draw_cpp_glb_decls"></a>
Global Type Declarations for Capture.cpp</h2>
<p>There are no OpenNI specific golbal declarations.</p>
<h2><a class="anchor" id="draw_cpp_fns_getpoweroftwo_to_setErrorState"></a>
Functions GetPowerOfTwo() to setErrorState()</h2>
<p>There are no OpenNI specific operations in these functions.</p>
<h2><a class="anchor" id="draw_cpp_drawcropstream"></a>
Function: drawCropStream() - Draws a Cropped Map from the Generator nodes</h2>
<p>This function draws a cropped map from each of the generator nodes.</p>
<p><b>Parameters:</b></p>
<p><code>pGenerator</code>: Specifies one of the three map generator nodes: DepthGenerator, ImageGenerator node, or ImageGenerator node.</p>
<p>First of all this function calls <a class="el" href="classxn_1_1_production_node.html#a26574447d96527d1a9d79994e550037f">xn::Generator::IsCapabilitySupported()</a> to check whether this OpenNI installation supports a cropping capability. </p>
<div class="fragment"><pre class="fragment">            <span class="keywordflow">if</span> (!pGenerator-&gt;IsCapabilitySupported(<a class="code" href="_xn_types_8h.html#adb1d497ae3a6ced5a4fa52182fa2b6e1">XN_CAPABILITY_CROPPING</a>))
            {
                <span class="keywordflow">return</span>;
            }
</pre></div><p>This function calls <a class="el" href="classxn_1_1_map_generator.html#a1fd1a64c376d7a47b2951bd996939644">xn::MapGenerator::GetMapOutputMode()</a> to get the Generator node's map output mode, which contains the node's current frame dimensions. the map output mode is obtaiend as an <a class="el" href="_xn_types_8h.html#aaa3272a330652ec83d7bf5330418c55c">XnMapOutputMode</a> structure. The frame dimensions are needed for drawing the map on the graphic display. </p>
<div class="fragment"><pre class="fragment">            <a class="code" href="struct_xn_map_output_mode.html">XnMapOutputMode</a> Mode;
            pGenerator-&gt;GetMapOutputMode(Mode);     
</pre></div><p>An OpenNI <a class="el" href="_xn_types_8h.html#abcf66e9732cef012b3127a4d3d373b98">xn::XnCropping</a> structure is used for containing the cropping location. Its fields are shown in the code block below. </p>
<div class="fragment"><pre class="fragment">            <a class="code" href="struct_xn_cropping.html">XnCropping</a> cropping;
            cropping.<a class="code" href="struct_xn_cropping.html#a9fe787dba0082b97e01d2bbf95c3be6a">bEnabled</a> = TRUE;
            cropping.<a class="code" href="struct_xn_cropping.html#a15dc3646d14d2dca176b306d675af223">nXOffset</a> = cropRect.uLeft;
            cropping.<a class="code" href="struct_xn_cropping.html#a7b33ecb40598d92ecc19a152e5b8e9ba">nYOffset</a> = cropRect.uBottom;
            cropping.<a class="code" href="struct_xn_cropping.html#ae1d6a8702c62d653271e2021acc73c8e">nXSize</a> = cropRect.uRight - cropRect.uLeft;
            cropping.<a class="code" href="struct_xn_cropping.html#ad154d03ef91067018261a55af94294e0">nYSize</a> = cropRect.uTop - cropRect.uBottom;

            <span class="keywordflow">if</span> ((cropping.<a class="code" href="struct_xn_cropping.html#a15dc3646d14d2dca176b306d675af223">nXOffset</a> % dividedBy) != 0)
                cropping.<a class="code" href="struct_xn_cropping.html#a15dc3646d14d2dca176b306d675af223">nXOffset</a> -= (cropping.<a class="code" href="struct_xn_cropping.html#a15dc3646d14d2dca176b306d675af223">nXOffset</a> % dividedBy);
            <span class="keywordflow">if</span> ((cropping.<a class="code" href="struct_xn_cropping.html#ae1d6a8702c62d653271e2021acc73c8e">nXSize</a> % dividedBy) != 0)
                cropping.<a class="code" href="struct_xn_cropping.html#ae1d6a8702c62d653271e2021acc73c8e">nXSize</a> += dividedBy - (cropping.<a class="code" href="struct_xn_cropping.html#ae1d6a8702c62d653271e2021acc73c8e">nXSize</a>
</pre></div><p>Finally, the function assigns the cropping setting to the Generator node. To do this it calls <a class="el" href="smpl_niviewer_device_cpp.html#device_cpp_setStreamCropping">&lt;code&gt;setStreamCropping()&lt;/code&gt;</a>, which si defined in the <code>Device.cpp</code> file of this sample program.</p>
<h2><a class="anchor" id="draw_cpp_drawSelectionChanged"></a>
Function: drawSelectionChanged() - Callback invoked when Draw Selection has Changed</h2>
<p>This callback is invoked when the draw selection has been changed.</p>
<p>This callback calls the <a class="el" href="smpl_niviewer_draw_cpp.html#draw_cpp_drawcropstream">Function: drawCropStream() - Draws a Cropped Map from the Generator nodes</a> function defined above for each valid Generator node. For example: </p>
<div class="fragment"><pre class="fragment">            <span class="keywordflow">if</span> (getDepthGenerator() != NULL &amp;&amp; g_DrawConfig.Streams.Depth.Coloring != DEPTH_OFF)
            {
                drawCropStream(getDepthGenerator(), g_DrawConfig.DepthLocation, selection, 2);
            }
</pre></div><h2><a class="anchor" id="draw_cpp_calculateHistogram"></a>
Function: calculateHistogram() - Calculates Depth Histogram</h2>
<p>This function uses the depth values to build an accumulative histogram of frequency of occurrence of each depth value. The *pDepth pointer accesses each value in the depth buffer. It then uses the value as an index into the g_pDepthHist histogram array.</p>
<h2><a class="anchor" id="draw_cpp_YUV422ToRGB888"></a>
Function: YUV422ToRGB888() - Converts Formats</h2>
<p>There are no OpenNI operations in this function. </p>
<div class="fragment"><pre class="fragment">            <span class="comment">// --------------------------------</span>
            <span class="comment">// Drawing</span>
            <span class="comment">// --------------------------------</span>
<span class="preprocessor">            #if (XN_PLATFORM == XN_PLATFORM_WIN32)</span>
<span class="preprocessor"></span>
            <span class="keywordtype">void</span> YUV422ToRGB888(<span class="keyword">const</span> XnUInt8* pYUVImage, XnUInt8* pRGBAImage, XnUInt32 nYUVSize, XnUInt32 nRGBSize)
            {       
                ...
                ...
</pre></div><h2><a class="anchor" id="draw_cpp_drawClosedStream"></a>
Function: drawClosedStream() - Converts Formats</h2>
<p>There are no OpenNI operations in this function.</p>
<h2><a class="anchor" id="draw_cpp_drawColorImage"></a>
Function: drawColorImage() - Draws the Color Image Map</h2>
<p>This function draws the color image map for either the ImageGenerator map or the IRGenerator node.</p>
<p>This function gets saved <a class="el" href="glossary.html#glos_frame_object">frame objects</a>, assigning them to <code>pImageMD</code> and draws them to the graphic display. The frame object is a snapshot of the generated data, saved as a metadata object, at a certain point in time. The <a class="el" href="classxn_1_1_output_meta_data.html#a3dc4bdaf58ce7b4600b8116abb295e4b">xn::OutputMetaData::Data()</a> method gets a pointer to the data frame of the frame object saved in the metadata. </p>
<div class="fragment"><pre class="fragment">            <span class="keywordflow">if</span> (isImageOn())
            {
                pImageMD = getImageMetaData();
                pImage = getImageMetaData()-&gt;Data();
            }
            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isIROn())
            {
                pImageMD = getIRMetaData();
                pImage = (<span class="keyword">const</span> XnUInt8*)getIRMetaData()-&gt;Data();
            }
            <span class="keywordflow">else</span>
                <span class="keywordflow">return</span>;     
</pre></div><p>The code block above gets a pointer to the data frame of the frame object saved in the metadata. The frame object is a snapshot of the generated data at a certain point in time.</p>
<p>The main draw operations are controlled by the following for-loop. </p>
<div class="fragment"><pre class="fragment">            <span class="keywordflow">for</span> (XnUInt16 nY = pImageMD-&gt;YOffset(); nY &lt; pImageMD-&gt;YRes() + pImageMD-&gt;YOffset(); nY++)
            {
                XnUInt8* pTexture = TextureMapGetLine(&amp;g_texImage, nY) + pImageMD-&gt;XOffset()*4;
                ...
                ...
</pre></div><p>The above loop provides the y indexes to access each pixel in the <code>DepthMap</code>. The <a class="el" href="classxn_1_1_map.html#a12df2e51951f42f4265e27e14d8d412b">YRes()</a> method returns the Y dimension -- height -- of the data frame.</p>
<p>The following code uses the FullXRes() to calculate the scaling factor between the depth map and the GL window. FullXRes() gets the full frame resolution, i.e., the entire field-of-view, ignoring cropping of the FOV in the scene. </p>
<div class="fragment"><pre class="fragment">            <span class="keywordflow">if</span> (pDepthMetaData != NULL)
            {
                XnDouble dRealX = (nX + pImageMD-&gt;XOffset()) / (XnDouble)pImageMD-&gt;FullXRes();
                XnDouble dRealY = nY / (XnDouble)pImageMD-&gt;FullYRes();

                XnUInt32 nDepthX = dRealX * pDepthMetaData-&gt;FullXRes() - pDepthMetaData-&gt;XOffset();
                XnUInt32 nDepthY = dRealY * pDepthMetaData-&gt;FullYRes() - pDepthMetaData-&gt;YOffset();

                <span class="keywordflow">if</span> (nDepthX &gt;= pDepthMetaData-&gt;XRes() || nDepthY &gt;= pDepthMetaData-&gt;YRes())
                {
                    nDepthIndex = -1;
                }
                <span class="keywordflow">else</span>
                {
                    nDepthIndex = nDepthY*pDepthMetaData-&gt;XRes() + nDepthX;
                }
            }       
</pre></div><h2><a class="anchor" id="draw_cpp_drawDepth"></a>
Function: drawDepth() - Draws the Depth Map</h2>
<p>This function is implemented in a way similar to that of the draw_cpp_drawColorImage function above.</p>
<p>Of note is the &lt;&gt;<code>++pDepth</code> term in the code block below. </p>
<div class="fragment"><pre class="fragment">            <span class="keywordflow">for</span> (XnUInt16 nY = pDepthMD-&gt;YOffset(); nY &lt; pDepthMD-&gt;YRes() + pDepthMD-&gt;YOffset(); nY++)
            {
                XnUInt8* pTexture = TextureMapGetLine(&amp;g_texDepth, nY) + pDepthMD-&gt;XOffset()*4;
                <span class="keywordflow">for</span> (XnUInt16 nX = 0; nX &lt; pDepthMD-&gt;XRes(); nX++, pDepth++, pTexture+=4)
</pre></div><p><b><code>++pDepth</code>:</b> This pointer is incremented by 1 for each inner loop. So it steps through all the pixels in the Depth map. Thus the program can get each pixel's depth value. </p>
</div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue Nov 12 2013 16:35:27 for OpenNI 1.5.7 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
