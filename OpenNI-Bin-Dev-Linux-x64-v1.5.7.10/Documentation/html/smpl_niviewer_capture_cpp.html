<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenNI 1.5.7: Capture.cpp file</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="OpenNILogo.bmp"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenNI 1.5.7
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">OpenNI Overview</a>      </li>
      <li class="navelem"><a class="el" href="smpls_n_guides.html">Samples and Guides</a>      </li>
      <li class="navelem"><a class="el" href="smpls.html">Sample Programs for the OpenNI API</a>      </li>
      <li class="navelem"><a class="el" href="smpl_niviewer.html">NiViewer - sample program</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Capture.cpp file </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Source files:</b> Click the following link to view the source code file:</p>
<ul>
<li>Capture.cpp</li>
</ul>
<p>This file contains the code for capturing frames from the OpenNI generator nodes.</p>
<h2><a class="anchor" id="capture_cpp_glb_decls"></a>
Global Type Declarations for Capture.cpp</h2>
<p>The Capture.cpp file's global type declarations comprise four type definitions, which are directly connected. The relationship between these four types is presented by by the following summary, with the key components only shown. </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">typedef</span> <span class="keyword">enum</span> { NOT_CAPTURING, ...   } CapturingState;
            <span class="keyword">typedef</span> <span class="keyword">enum</span> { CAPTURE_DEPTH_NODE,..., CAPTURE_NODE_COUNT } CaptureNodeType;
            <span class="keyword">typedef</span> <span class="keyword">struct </span>NodeCapturingData {  ... } NodeCapturingData;            
            <span class="keyword">typedef</span> <span class="keyword">struct </span>CapturingData
            {
                NodeCapturingData nodes[CAPTURE_NODE_COUNT];
                ...
                ...
                CapturingState State;
                ...
            } CapturingData;
            
            <span class="comment">// --------------------------------</span>
            <span class="comment">// Global Variables</span>
            <span class="comment">// --------------------------------</span>
            CapturingData g_Capture;    
</pre></div><p>In summary, the major data type is the <code>CapturingData</code> structure, for which a single run-time data instance, <code>g_Capture</code>, is defined, as above, and is used extensively throughout the Capture.cpp module.</p>
<p>As shown above, <code>g_Capture</code> includes the <code>nodes</code> array, containing an entry of type <code>NodeCapturingData</code> for one each of the (four - CAPTURE_NODE_COUNT) types of generator nodes, <a class="el" href="classxn_1_1_depth_generator.html">Depth</a>, <a class="el" href="classxn_1_1_image_generator.html">Image</a>, <a class="el" href="classxn_1_1_i_r_generator.html">IR</a>, and <a class="el" href="classxn_1_1_audio_generator.html">Audio</a> generators. A key data field of <code>NodeCapturingData</code> is <code>pGenerator</code>, for pointing to one of the above generators.</p>
<p>These structures are described separately and in some detail in the subsections further below.</p>
<h3><a class="anchor" id="capture_cpp_glb_decls_CapturingState"></a>
Type definition:  CapturingState enum</h3>
<p>The <code>CapturingState</code> type is defined as below. It defines a field in the <code>CapturingData</code> structure. It is used as the state controller in the getCaptureMessage() state machine. </p>
<div class="fragment"><pre class="fragment">                <span class="keyword">typedef</span> <span class="keyword">enum</span>
                {
                    NOT_CAPTURING,
                    SHOULD_CAPTURE,
                    CAPTURING,
                } CapturingState;
</pre></div><h3><a class="anchor" id="capture_cpp_glb_decls_CaptureNodeType"></a>
Type definition:   CaptureNodeType enum</h3>
<p>This type contains enum items for specifying esch of the generator nodes. </p>
<div class="fragment"><pre class="fragment">                <span class="keyword">typedef</span> <span class="keyword">enum</span>
                {
                    CAPTURE_DEPTH_NODE,
                    CAPTURE_IMAGE_NODE,
                    CAPTURE_IR_NODE,
                    CAPTURE_AUDIO_NODE,
                    CAPTURE_NODE_COUNT
                } CaptureNodeType;
</pre></div><p> The <code>CaptureNodeType</code> type itself is not currently directly used.</p>
<h3><a class="anchor" id="capture_cpp_glb_decls_NodeCapturingData"></a>
Type definition:   NodeCapturingData structure</h3>
<p>The <code>NodeCapturingData</code> type is defined as below. It defines a field in the <code>CapturingData</code> structure. It is used as the state controller in the getCaptureMessage() state machine. </p>
<div class="fragment"><pre class="fragment">                <span class="keyword">typedef</span> <span class="keyword">struct </span>NodeCapturingData
                {
                    <a class="code" href="_xn_types_8h.html#a0c078fc21c85436c606efc6384eeb45f">XnCodecID</a> captureFormat;
                    XnUInt32 nCapturedFrames;
                    <span class="keywordtype">bool</span> bRecording;
                    <a class="code" href="classxn_1_1_generator.html">xn::Generator</a>* pGenerator;
                } NodeCapturingData;
</pre></div><p><code>captureFormat</code>: For containing the current codec enum ID of a generator node. Note that later in this file (in <a class="el" href="smpl_niviewer_capture_cpp.html#capture_cpp_captureinit">Function: captureInit() - Initializes the Primary Stream and the Resolutions</a>) <em>all</em> of the codec text names and enum IDs for each node type area stored (in <code>g_DepthFormat.pValues[]</code> and <code>g_DepthFormat.pIndexToName[nIndex]</code>).</p>
<h3><a class="anchor" id="capture_cpp_glb_decls_CapturingData"></a>
Type definition:  CapturingData struct</h3>
<div class="fragment"><pre class="fragment">                <span class="keyword">typedef</span> <span class="keyword">struct </span>CapturingData
                {
                    NodeCapturingData nodes[CAPTURE_NODE_COUNT];
                    Recorder* pRecorder;
                    <span class="keywordtype">char</span> csFileName[XN_FILE_MAX_PATH];
                    XnUInt32 nStartOn; <span class="comment">// time to start, in seconds</span>
                    <span class="keywordtype">bool</span> bSkipFirstFrame;
                    CapturingState State;
                    XnUInt32 nCapturedFrameUniqueID;
                    <span class="keywordtype">char</span> csDisplayMessage[500];
                } CapturingData;            
</pre></div><h2><a class="anchor" id="capture_cpp_glb_vars"></a>
Global Variable Declarations for Capture.cpp</h2>
<p>The Capture.cpp file's global variable declarations includes the central <code>g_Capture</code> variable and a format variable of <code>NodeCodec</code> type for each of the four generator nodes - see the declaration block below. <code>NodeCodec</code> is defined in <code>Device.h</code>. It contains codec definitions for all the codecs of each generator node.</p>
<div class="fragment"><pre class="fragment">            <span class="comment">// --------------------------------</span>
            <span class="comment">// Global Variables</span>
            <span class="comment">// --------------------------------</span>
            CapturingData g_Capture;

            NodeCodec g_DepthFormat;
            NodeCodec g_ImageFormat;
            NodeCodec g_IRFormat;
            NodeCodec g_AudioFormat;
</pre></div><h2><a class="anchor" id="capture_cpp_captureinit"></a>
Function: captureInit() - Initializes the Primary Stream and the Resolutions</h2>
<p>This function initializes the main <code>g_Capture</code> variable and the <code>NodeCodec</code> structures, for example, <code>g_DepthFormat</code>.</p>
<p>Following are examples of <code>NodeCodec</code> structures. Note that for each Generator node there can be a number of codes defined. For example, in the code sample below, for the DepthGenerator node there are defined the codecs XN_CODEC_16Z_EMB_TABLES and XN_CODEC_UNCOMPRESSED. </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">void</span> captureInit()
            {
                <span class="comment">// Depth Formats</span>
                <span class="keywordtype">int</span> nIndex = 0;

                g_DepthFormat.pValues[nIndex] = <a class="code" href="_xn_codec_i_ds_8h.html#aba0b76d523d3ad9c58d8f7333016e787">XN_CODEC_16Z_EMB_TABLES</a>;
                g_DepthFormat.pIndexToName[nIndex] = <span class="stringliteral">&quot;PS Compression (16z ET)&quot;</span>;
                nIndex++;

                g_DepthFormat.pValues[nIndex] = <a class="code" href="_xn_codec_i_ds_8h.html#acabe5c8901aa201b4b0a860c9ac5ac6a">XN_CODEC_UNCOMPRESSED</a>;
                g_DepthFormat.pIndexToName[nIndex] = <span class="stringliteral">&quot;Uncompressed&quot;</span>;
                nIndex++;
                ...
                ...
</pre></div><p>Each entry in the g_DepthFormat.pValues[] array specifies a codec ID, e.g., <a class="el" href="_xn_codec_i_ds_8h.html#aba0b76d523d3ad9c58d8f7333016e787">xn::XN_CODEC_16Z_EMB_TABLES</a>. Each entry in the <code>g_DepthFormat.pIndexToName[]</code> array specifies a human readable text name for the codec, e.g., "&lt;code&gt;PS Compression (16z ET)&lt;/code&gt;".</p>
<p>The <code>g_Capture</code> data structure variable is initialized as follows. </p>
<div class="fragment"><pre class="fragment">            g_Capture.csFileName[0] = 0;
            g_Capture.State = NOT_CAPTURING;
            g_Capture.nCapturedFrameUniqueID = 0;
            g_Capture.csDisplayMessage[0] = <span class="charliteral">&#39;\0&#39;</span>;
            g_Capture.bSkipFirstFrame = <span class="keyword">false</span>;

            g_Capture.nodes[CAPTURE_DEPTH_NODE].captureFormat = <a class="code" href="_xn_codec_i_ds_8h.html#aba0b76d523d3ad9c58d8f7333016e787">XN_CODEC_16Z_EMB_TABLES</a>;
            g_Capture.nodes[CAPTURE_IMAGE_NODE].captureFormat = <a class="code" href="_xn_codec_i_ds_8h.html#a9dd32da2907ebe7cae19a3e90b16275e">XN_CODEC_JPEG</a>;
            g_Capture.nodes[CAPTURE_IR_NODE].captureFormat = <a class="code" href="_xn_codec_i_ds_8h.html#acabe5c8901aa201b4b0a860c9ac5ac6a">XN_CODEC_UNCOMPRESSED</a>;
            g_Capture.nodes[CAPTURE_AUDIO_NODE].captureFormat = <a class="code" href="_xn_codec_i_ds_8h.html#acabe5c8901aa201b4b0a860c9ac5ac6a">XN_CODEC_UNCOMPRESSED</a>;
</pre></div><p>Note in the above initializations:</p>
<ul>
<li>Capture State -- in <code>g_Capture.State</code> -- is initialized to <code>NOT_CAPTURING</code>.</li>
</ul>
<ul>
<li>g_Capture.nodes[] is a list of <code>captureFormat</code> structures and it is initialized to contain the current codecs to be used for each Generator node. Note that earlier in this function <em>all</em> of the codecs for each node type have been stored in <code>g_DepthFormat.pValues[]</code> and <code>g_DepthFormat.pIndexToName[nIndex]</code>.</li>
</ul>
<h2><a class="anchor" id="capture_cpp_isCapturing"></a>
Function: isCapturing() - Are the Generator nodes in  Capturing State</h2>
<p>Returns whther the generator nodes are currently attempting to capture frames. </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">bool</span> isCapturing()
            {
                <span class="keywordflow">return</span> (g_Capture.State != NOT_CAPTURING);
            }
</pre></div><h2><a class="anchor" id="capture_cpp_OpenWriteDevice"></a>
Function: captureOpenWriteDevice() -  Open a Write Device</h2>
<p>The following code block calls <a class="el" href="classxn_1_1_context.html#a4e1316931421c0a36bd89ea6394c98ae">EnumerateProductionTrees</a> to list all available <a class="el" href="classxn_1_1_recorder.html">Recorder</a> production nodes and returns a full list of the matching production nodes. The chosen pointer picks the first in the list, and to select the <a class="el" href="classxn_1_1_node_info.html">NodeInfo</a> information of a <a class="el" href="classxn_1_1_recorder.html">Recorder</a> node for recording a data generation session. </p>
<div class="fragment"><pre class="fragment">            NodeInfoList recordersList;
            nRetVal = g_Context.<a class="code" href="classxn_1_1_context.html#a4e1316931421c0a36bd89ea6394c98ae" title="Enumerates all available production nodes for a specific node type (e.g., the application wants to cr...">EnumerateProductionTrees</a>(<a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52ab692ee9629e719de76e3667fd628a2ab">XN_NODE_TYPE_RECORDER</a>, NULL, recordersList);
            NodeInfo chosen = *recordersList.Begin();
</pre></div><p>The following code block creates a <a class="el" href="prod_graph.html">production graph</a> for the selected <a class="el" href="classxn_1_1_recorder.html">Recorder</a> node. A pointer to the Recorder is held to the <code>g_Capture</code> variable. </p>
<div class="fragment"><pre class="fragment">            g_Capture.pRecorder = <span class="keyword">new</span> Recorder;
            nRetVal = g_Context.<a class="code" href="classxn_1_1_context.html#adaa8daba096969ff9f16b7e8cb35cf93" title="Creates a production node from the information supplied in a xn::NodeInfo object.">CreateProductionTree</a>(chosen, *g_Capture.pRecorder);
            START_CAPTURE_CHECK_RC(nRetVal, <span class="stringliteral">&quot;Create recorder&quot;</span>);
</pre></div><p>Finally, the destnation file or the recording is set, as follows. </p>
<div class="fragment"><pre class="fragment">            nRetVal = g_Capture.pRecorder-&gt;SetDestination(<a class="code" href="group__recorder.html#gga3a9ee4c35a7384ba06a4d22f976f8e8aab2fd201e9160a675b83ca2a3e4d36a0c">XN_RECORD_MEDIUM_FILE</a>, g_Capture.csFileName);         
</pre></div><h2><a class="anchor" id="capture_cpp_Browse"></a>
Function: captureBrowse() -  Opens a Write Device</h2>
<p>This function opens the write device.</p>
<p>as we waited for user input, it's probably better to discard first frame (especially if an accumulating stream is on, like audio).</p>
<h2><a class="anchor" id="capture_cpp_Start"></a>
Function: captureStart() -  Starts the Capturing Process</h2>
<p>This function starts capturing process. The important features are that it sets the tiem for starting capturing by assigning the current time to <code>g_Capture</code> weit an added delay; and then it sets the Capture state to SHOULD_CAPTURE, indicating taht a future time has been set for starting capturing. This is shown below. </p>
<div class="fragment"><pre class="fragment">            XnUInt64 nNow;
            <a class="code" href="_xn_o_s_8h.html#adff8a9df80de16d87002c145f59ca092">xnOSGetTimeStamp</a>(&amp;nNow);
            nNow /= 1000;
        
            g_Capture.nStartOn = (XnUInt32)nNow + nDelay;
            g_Capture.State = SHOULD_CAPTURE;
</pre></div><h2><a class="anchor" id="capture_cpp_CloseWriteDevice"></a>
Function: captureCloseWriteDevice() -  Closes a Write Device</h2>
<p>This function closes a write device. Among the 'close' operations, it calls <a class="el" href="classxn_1_1_node_wrapper.html#ad94e45cb0bbd21223ed17e77c6893ca6">Release()</a> to Unreference a production node. This decreases its reference count by 1. If the reference count reaches zero, the node will be destroyed. </p>
<div class="fragment"><pre class="fragment">            <span class="keywordflow">if</span> (g_Capture.pRecorder != NULL)
            {
                g_Capture.pRecorder-&gt;Release();
                <span class="keyword">delete</span> g_Capture.pRecorder;
                g_Capture.pRecorder = NULL;
            }
</pre></div><h2><a class="anchor" id="capture_cpp_captureRestart"></a>
Function: captureRestart() -  Restarts the Recording Process</h2>
<p>This function restarts the recording module. It simply uses the <code>captureCloseWriteDevice()</code> defined just above to close the recording device. This function then reopens the recording module by using the <code>captureOpenWriteDevice()</code> defined further above. <code>g_Capture.State</code> remains at it current state.</p>
<h2><a class="anchor" id="capture_cpp_captureStop"></a>
Function: captureStop() -  Stops the Recording Process</h2>
<p>This function stops the recording module, i.e., it puts it into NOT_CAPTURING state. Thus, for this purpose CAPTURING state and SHOULD_CAPTURE state are both defined as 'capturing state'. This function simply uses the <code>captureCloseWriteDevice()</code> defined just above to close the recording device.</p>
<h2><a class="anchor" id="capture_cpp_captureFrame"></a>
Function: captureFrame() -  Main State Machine for Capturing Frames from Generator Nodes</h2>
<p>This function is the main state machine for capturing frames from generator nodes. This function processes two states: CAPTURING state and SHOULD_CAPTURE state.</p>
<h3><a class="anchor" id="capture_cpp_captureframe_should_capture_st"></a>
SHOULD_CAPTURE state</h3>
<p>In this state, this function add nodes to the recording.</p>
<p>This function first checks if the capture time has been reached. (This time delay was set in the <a class="el" href="smpl_niviewer_capture_cpp.html#capture_cpp_Start">captureStart() function</a>.) </p>
<div class="fragment"><pre class="fragment">                <span class="keywordflow">if</span> (g_Capture.State == SHOULD_CAPTURE)
                {
                    XnUInt64 nNow;
                    <a class="code" href="_xn_o_s_8h.html#adff8a9df80de16d87002c145f59ca092">xnOSGetTimeStamp</a>(&amp;nNow);
                    nNow /= 1000;

                    <span class="comment">// check if time has arrived</span>
                    <span class="keywordflow">if</span> (nNow &gt;= g_Capture.nStartOn)         
</pre></div><p>Once the capture time and started and this function starts to capture, it performs some initialization and sets the Capturing state to CAPTURING state. </p>
<div class="fragment"><pre class="fragment">                g_Capture.State = CAPTURING;
</pre></div><p>The following 'if' statement adds a valid device node to the recorder. This is for recording raw input data from the device. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordflow">if</span> (getDevice() != NULL)
                {
                    nRetVal = g_Capture.pRecorder-&gt;AddNodeToRecording(*getDevice(), <a class="code" href="_xn_codec_i_ds_8h.html#acabe5c8901aa201b4b0a860c9ac5ac6a">XN_CODEC_UNCOMPRESSED</a>);
                    START_CAPTURE_CHECK_RC(nRetVal, <span class="stringliteral">&quot;add device node&quot;</span>);
                }
</pre></div><p>The <a class="el" href="classxn_1_1_recorder.html#aa6023d6f933e831504c6ddaa8357927f">xn::Recorder::AddNodeToRecording()</a> adds a node to the recording setup, and starts recording data that the node generates. This method must be called for each node to be recorded with this recorder. The call passes as parameters a pointer to the node and the enum ID of the codec to be used.</p>
<p>The following sequence of 'if' statements adds nodes to the recorder. A node is added to the recorder only if:</p>
<ul>
<li>the node is 'On' (e.g., <code>g_bIsDepthOn=true</code> for a DepthGenerator node), and</li>
<li>the node's <code>captureFormat</code> is defined (i.e., <code>captureFormat!= CODEC_DONT_CAPTURE</code> As an example, the following code block shows the code for the DepthGenerator node. <div class="fragment"><pre class="fragment">                <span class="keywordflow">if</span> (isDepthOn() &amp;&amp; (g_Capture.nodes[CAPTURE_DEPTH_NODE].captureFormat != CODEC_DONT_CAPTURE))
                {
                    nRetVal = g_Capture.pRecorder-&gt;AddNodeToRecording(*getDepthGenerator(), g_Capture.nodes[CAPTURE_DEPTH_NODE].captureFormat);
                    START_CAPTURE_CHECK_RC(nRetVal, <span class="stringliteral">&quot;add depth node&quot;</span>);
                    g_Capture.nodes[CAPTURE_DEPTH_NODE].bRecording = TRUE;
                    g_Capture.nodes[CAPTURE_DEPTH_NODE].pGenerator = getDepthGenerator();
                }
</pre></div></li>
</ul>
<p>In the above, the code saves in <code>g_Capture</code> a pointer to the DepthGenerator node by assigning the return result of <code>getDepthGenerator()</code>.</p>
<h3><a class="anchor" id="capture_cpp_captureframe_capturing_st"></a>
CAPTURING state</h3>
<p>In this state, this function starts recording data generated from the nodes.</p>
<p>Once all required nodes are added, the application can read data from the nodes and record it. Recording of data can be achieved either by explicitly calling the <a class="el" href="classxn_1_1_recorder.html#a94a2c702fd2c5e2466b813bb585e6fc9">xn::Recorder::Record()</a> method, or by using one of the <a class="el" href="conc_updating_data.html">'Update All'</a> functions. This function demonstrates using the Record() method. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordflow">if</span> (g_Capture.State == CAPTURING)
                {
                    nRetVal = g_Capture.pRecorder-&gt;Record();
                    ...
</pre></div><p>There isn't a real need to call Record() here, as the WaitXUpdateAll() call from <code>IdleCallback()</code> in the <code>NiView.cpp</code> file already makes sure that recording is performed.</p>
<p>The following loop counts recorded frames. It uses the <a class="el" href="classxn_1_1_generator.html#a46b2960e843339296201682c04c02b5d">xn::Generator::IsDataNew()</a> method to test of a generate nodfe has actually generated new data. the IsDataNew() method returns whether the node's frame data was updated by the most recent call to any 'WaitXUpdateAll' function (e.g., <a class="el" href="classxn_1_1_context.html#a52929d2a535166b18098e066900f9d59">xn::Context::WaitAndUpdateAll()</a>). </p>
<div class="fragment"><pre class="fragment">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; CAPTURE_NODE_COUNT; ++i)
                {
                    <span class="keywordflow">if</span> (g_Capture.nodes[i].bRecording &amp;&amp; g_Capture.nodes[i].pGenerator-&gt;IsDataNew())
                        g_Capture.nodes[i].nCapturedFrames++;
                }
</pre></div><h2><a class="anchor" id="capture_cpp_setformat"></a>
Function: captureSetFormat() -  Selects a New Codec for Recording</h2>
<p>This function is used by a number of individual 'Set Format' functions (e.g., captureSetDepthFormat() - described further below) to select a new codec for recording.</p>
<p><b>Parameters:</b></p>
<p><code>pMember</code>: the old format <br/>
 <code>newFormat</code>: the new format<br/>
 <code>node</code>: ProductionNode specifier</p>
<p>If a state change is being requested, i.e., from 'not capture' to 'capture', or the reverse, then the node is <a class="el" href="classxn_1_1_recorder.html#aa6023d6f933e831504c6ddaa8357927f">added to</a> or <a class="el" href="classxn_1_1_recorder.html#aa6023d6f933e831504c6ddaa8357927f">removed from</a> the Recorder, accordingly.</p>
<p>If a codec change is being requested, then the node removed from the Recorder and then added again, this time with the new codec.</p>
<h2><a class="anchor" id="capture_cpp_setformat_grp"></a>
Function group: 'Set Format' for each Production Node</h2>
<p>All functions in this group call the captureSetFormat() described above. For example: </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">void</span> captureSetDepthFormat(<span class="keywordtype">int</span> format)
            {
                captureSetFormat(&amp;g_Capture.nodes[CAPTURE_DEPTH_NODE].captureFormat, format, *getDepthGenerator());
            }
            ...
            ...
</pre></div><h2><a class="anchor" id="capture_cpp_getCodecName"></a>
Function: getCodecName() -  Gets Text Name of Node's  Current Codec</h2>
<p>This function gets the text name of the current codec being used for a specific node.</p>
<p>This function is used by a number of individual 'GetDepthFormatName' functions (e.g., captureGetImageFormatName() - described further below) to get the text name of a specified codec from the list of all possible codecs for a specific node.</p>
<p><b>Parameters:</b></p>
<p><code>pNodeCodec</code>: a specific generator node's list of all codec ID info (text name and ID enum), e.g., this function is called with g_DepthFormat passed as this parameter</p>
<p><code>codecID</code>: the enum ID of the codec currently being used for the specific generator node </p>
<div class="fragment"><pre class="fragment">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; pNodeCodec-&gt;nValuesCount; i++)
            {
                <span class="keywordflow">if</span> (pNodeCodec-&gt;pValues[i] == codecID)
                {
                    <span class="keywordflow">return</span> pNodeCodec-&gt;pIndexToName[i];
                }
            }
</pre></div><h2><a class="anchor" id="capture_cpp_getCodecName_grp"></a>
Function group: 'getCodecName' for each Generator node</h2>
<p>All functions in this group call the getCodecName() described above. For example: </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">const</span> <span class="keywordtype">char</span>* captureGetDepthFormatName()
            {
                <span class="keywordflow">return</span> getCodecName(&amp;g_DepthFormat, g_Capture.nodes[CAPTURE_DEPTH_NODE].captureFormat);
            }
</pre></div><h2><a class="anchor" id="capture_cpp_getCaptureMessage"></a>
Function: 'getCaptureMessage()'</h2>
<p>This function builds a capture message according to the current Capture State.</p>
<p>In this function, there is one OpenNI method of note - the <a class="el" href="classxn_1_1_node_wrapper.html#ae9e08bd23c07bf858c7f1ec1b3b658c4">xn::NodeWrapper::GetName()</a> method - see the 'case' block below. </p>
<div class="fragment"><pre class="fragment">            <span class="keywordflow">case</span> CAPTURING:
            {
                <span class="keywordtype">int</span> nChars = sprintf(pMessage, <span class="stringliteral">&quot;* Recording! Press any key or use menu to stop *\nRecorded Frames: &quot;</span>);
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; CAPTURE_NODE_COUNT; ++i)
                {
                    <span class="keywordflow">if</span> (g_Capture.nodes[i].bRecording)
                    {
                        nChars += sprintf(pMessage + nChars, <span class="stringliteral">&quot;%s-%d &quot;</span>, g_Capture.nodes[i].pGenerator-&gt;GetName(), g_Capture.nodes[i].nCapturedFrames);
                    }
                }
            }
</pre></div><p>The GetName() method gets the instance name of a node. Unless the application made a specific request for a specific name, the name will be of the form: "Depth1", "Image2", etc.</p>
<p>GetName() is a member of the <a class="el" href="classxn_1_1_node_wrapper.html">NodeWrapper</a> class. The NodeWrapper class is the base class for all OpenNI node classes in C++, for example, the <a class="el" href="classxn_1_1_production_node.html">xn::ProductionNode</a> class and the <a class="el" href="classxn_1_1_generator.html">xn::Generator</a> class.</p>
<h2><a class="anchor" id="capture_cpp_getFileName_grp"></a>
Function group: 'Get File Name' - Build a file name for each Generator node</h2>
<p>All functions in this group build a file name (from a path and ID number) for saving a captured data frame. For example: </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">const</span> <span class="keywordtype">char</span>* captureGetDepthFormatName()
            {
                <span class="keywordflow">return</span> getCodecName(&amp;g_DepthFormat, g_Capture.nodes[CAPTURE_DEPTH_NODE].captureFormat);
            }
</pre></div><p> This unique file name is later to save a captured data frame to a file for storage.</p>
<p>All the functions in this group are called from the findUniqueFileName() function (described immediately below)</p>
<h2><a class="anchor" id="capture_cpp_findUniqueFileName"></a>
Function: findUniqueFileName() -  Builds a Unique File Name for Saving a Captured Data Frame</h2>
<p>This function builds a unique file name for saving a captured data frame.</p>
<p>The purpose of this function is straightforward and there are no OpenNI specific operations in this function.</p>
<h2><a class="anchor" id="capture_cpp_captureSingleFrame"></a>
Function: captureSingleFrame() -  Captures a Single Frame</h2>
<p>This function captures a single data frame from each generator node.</p>
<p>The function first builds for each generator node a unique file name for saving the data frame.</p>
<p>Then the function gets a <a class="el" href="glossary.html#glos_frame_object">frame object</a> for each generator node. A "frame object" is a data frame and associated configuration information saved from a generator node. For example, </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">const</span> ImageMetaData* pImageMD = getImageMetaData();
            <span class="keywordflow">if</span> (pImageMD != NULL)
            {
                <a class="code" href="_xn_o_s_8h.html#a2508383ae34cec558938ee754be51cac">xnOSSaveFile</a>(csImageFileName, pImageMD-&gt;Data(), pImageMD-&gt;DataSize());
            }
</pre></div><p>In this sample program, the frame objects are stored as metadata objects in the <code>readFrame() </code>function in the <code>Device.cpp</code> file of this program sample. getImageMetaData() is also a function in this sample program for simply getting the frame object that was already saved. </p>
</div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue Nov 12 2013 16:35:27 for OpenNI 1.5.7 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
