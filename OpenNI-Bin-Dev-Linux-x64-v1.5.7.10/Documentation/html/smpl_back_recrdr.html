<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenNI 1.5.7: NiBackRecorder.cpp - sample program</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="OpenNILogo.bmp"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenNI 1.5.7
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">OpenNI Overview</a>      </li>
      <li class="navelem"><a class="el" href="smpls_n_guides.html">Samples and Guides</a>      </li>
      <li class="navelem"><a class="el" href="smpls.html">Sample Programs for the OpenNI API</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">NiBackRecorder.cpp - sample program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Source file:</b> Click the following link to view the source code file:</p>
<ul>
<li>NiBackRecorder\main.cpp</li>
</ul>
<p>The program saves the most recently generated depth and image data. The length of the recorded period is configurable. The save mechanism works by storing frames in memory in a cyclic buffer. On user request the program dumps the buffer to an ONI file.</p>
<p>The documentation describes the sample program's code from the top of the program file(s) to bottom.</p>
<p>Every OpenNI feature is described the first time it appears in this sample program. Further appearances of the same feature are not described again.</p>
<h2><a class="anchor" id="bkrec_decls"></a>
Program Declarations</h2>
<p>The following declares the RGB definitions for two output modes: QVGA and VGA. The mode is the OpenNI type <a class="el" href="_xn_types_8h.html#aaa3272a330652ec83d7bf5330418c55c">XnMapOutputMode</a> struct. For example, QVGAMode comprises a width+height of resolution 320x240 and a frame rate of 30 fps (frames per second). </p>
<div class="fragment"><pre class="fragment">            <a class="code" href="struct_xn_map_output_mode.html">XnMapOutputMode</a> QVGAMode = { 320, 240, 30 };
            <a class="code" href="struct_xn_map_output_mode.html">XnMapOutputMode</a> VGAMode = { 640, 480, 30 };
</pre></div><p>The following declaration block declares the <code>RecConfiguration</code> struct to contain the recording configuration. The constructor initializes its values. </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">struct </span>RecConfiguration
            {
              ...
            }
</pre></div><p>The <code>RecConfiguration</code> struct's fields and initializations are described in the following table. </p>
<table class="doxtable">
<tr>
<th>Configuration Setting </th><th>Description  </th></tr>
<tr>
<td>pDepthMode </td><td>Represents the user setting of the map output mode of the <a class="el" href="classxn_1_1_depth_generator.html">DepthGenerator</a> node. <br/>
 Initialized to QVGAMode.  </td></tr>
<tr>
<td>pImageMode </td><td><p class="starttd">Represents the user setting of the map output mode of the <a class="el" href="classxn_1_1_image_generator.html">ImageGenerator</a> node. <br/>
 Initialized to QVGAMode. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>bRecordDepth </td><td><p class="starttd">Represents the user setting of whether to record the output of the DepthGenerator node. <br/>
 Initialized to FALSE. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>bRecordImage </td><td><p class="starttd">Represents the user setting of whether to record the output of the ImageGenerator node. <br/>
 Initialized to FALSE. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>bMirrorIndicated </td><td><p class="starttd">Indicates that the user provided the <code>bMirror</code> setting to enable or disable a node's mirroring (assuming the node supports mirroring). <br/>
 Initialized to FALSE (i.e., at initialization time the user has not yet supplied a parameter). </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>bMirror </td><td><p class="starttd">Represents the user setting of whether to enable or disable a node's mirroring (assuming the node supports mirroring). <br/>
 Initialized to TRUE. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>bRegister </td><td><p class="starttd">Indicates whether registration between depth and image should be activated through OpenNI's AlternativeViewPoint capability. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>bFrameSync </td><td><p class="starttd">Represents the user setting of whether to synchronize between depth and image. That is, the depth and image frames that arrive from the sensor will always arrive in matching pairs (as indicated by the frames' timestamp fields).  </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>bVerbose </td><td><p class="starttd">Set to TRUE to turn on the log; FALSE to turn off the log, and no log messages at all are printed.  </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>nDumpTime </td><td><p class="starttd">Represents the user's time period setting for the buffer size. This is the number of seconds of data that can be saved to the cyclic buffer without overwriting previous saved data.  </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>strDirName </td><td><p class="starttd">Represents the user setting of the full path name, including the file name, to where to write the output data file.<br/>
 </p>
<p class="endtd"></p>
</td></tr>
</table>
<h2><a class="anchor" id="bkrec_cfg_gens"></a>
ConfigureGenerators() function</h2>
<p>This function configures the generator nodes. The function takes references to generator parameters, as shown in the function's header below. The OpenNI objects passed by these parameters help produce the OpenNI <a class="el" href="prod_graph.html">production graph</a> and they are described separately in the following paragraphs. </p>
<div class="fragment"><pre class="fragment">            <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> ConfigureGenerators(<span class="keyword">const</span> RecConfiguration&amp; config, <a class="code" href="classxn_1_1_context.html">xn::Context</a>&amp; context, <a class="code" href="classxn_1_1_depth_generator.html">xn::DepthGenerator</a>&amp; depthGenerator, <a class="code" href="classxn_1_1_image_generator.html">xn::ImageGenerator</a>&amp; imageGenerator)
            {
             ...
            }
</pre></div><h3><a class="anchor" id="bkrec_cfg_gens_dec"></a>
Meaning of the Parameters of the ConfigureGenerators() function</h3>
<p>The <em><a class="el" href="prod_graph.html">production graph</a></em> is a network of objects - called <a class="el" href="classxn_1_1_production_node.html">production nodes</a> - that work together to produce data for Natural Interface applications. <a class="el" href="classxn_1_1_generator.html">xn::Generator</a> "Generator" nodes are a particular type of production node, which generate data.</p>
<p>A <a class="el" href="classxn_1_1_context.html">Context</a> object is a workspace in which the application builds an OpenNI production graph. </p>
<div class="fragment"><pre class="fragment">                <a class="code" href="classxn_1_1_context.html">xn::Context</a>&amp; context
</pre></div><p>A <a class="el" href="classxn_1_1_depth_generator.html">DepthGenerator</a> node generates a depth map. Each map pixel value represents a distance from the sensor. </p>
<div class="fragment"><pre class="fragment">                <a class="code" href="classxn_1_1_depth_generator.html">xn::DepthGenerator</a>&amp; depthGenerator
</pre></div><p>An <a class="el" href="classxn_1_1_image_generator.html">ImageGenerator</a> node generates color image maps of various formats, such as the RGB24 image format. </p>
<div class="fragment"><pre class="fragment">                <a class="code" href="classxn_1_1_image_generator.html">xn::ImageGenerator</a>&amp; imageGenerator
</pre></div><p>The body of the ConfigureGenerators() function is described in the following subsections.</p>
<h3><a class="anchor" id="bkrec_cfg_gens_dec"></a>
Meaning of the Parameters of the ConfigureGenerators() function</h3>
<p>The declaration block at the top of the main program declares an OpenNI status flag for collecting return values from method calls. It initializes it with <code><a class="el" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">xn::XN_STATUS_OK</a></code>, the OpenNI value for valid status. Also declared is an OpenNI <a class="el" href="classxn_1_1_enumeration_errors.html">xn::EnumerationErrors</a> <code>error</code>list for collecting any errors that may occur. </p>
<div class="fragment"><pre class="fragment">                <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> nRetVal = <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>;
                <a class="code" href="classxn_1_1_enumeration_errors.html">xn::EnumerationErrors</a> errors;
</pre></div><h3><a class="anchor" id="bkrec_cfg_depth"></a>
Configures the DepthGenerator node</h3>
<p>Configures the DepthGenerator node, if needed. OpenNI functions in the body of this 'if' branch are described separately. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordflow">if</span> (config.bRecordDepth)
                {
                    ...
                }
</pre></div><p>In the following statement, the call to <a class="el" href="classxn_1_1_context.html#a4dba9b1553322cfb4ecdff6b6c93a182">xn::Context::CreateAnyProductionTree()</a> enumerates for production nodes of a specific node type, and creates the first production node found of that type. A reference to a <a class="el" href="classxn_1_1_depth_generator.html">DepthGenerator</a> node is returned in depthGenerator. </p>
<div class="fragment"><pre class="fragment">                nRetVal = context.CreateAnyProductionTree(<a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a1415a428ab99e92cebedd4fdb1fe74c6">XN_NODE_TYPE_DEPTH</a>, NULL, depthGenerator, &amp;errors);
</pre></div><p> See also <a class="el" href="prod_graph.html#create_method">Understanding the Create() method</a> for more detail.</p>
<p>The following statement sets the map output mode of a <a class="el" href="classxn_1_1_depth_generator.html">DepthGenerator</a> node. </p>
<div class="fragment"><pre class="fragment">                nRetVal = depthGenerator.SetMapOutputMode(*config.pDepthMode);
</pre></div><p>The following code turns on the requested capabilities if they are supported. For example, the following code checks if the "DepthGenerator" node supports the <a class="el" href="classxn_1_1_mirror_capability.html">MirrorCapability</a>, and if so, it gets the capability object and enables the node's mirroring. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordflow">if</span> (config.bMirrorIndicated &amp;&amp; depthGenerator.IsCapabilitySupported(<a class="code" href="_xn_types_8h.html#a86a5cfe5a7b10ebff110ea7ec5c1fb5c">XN_CAPABILITY_MIRROR</a>))
                {
                    depthGenerator.GetMirrorCap().SetMirror(config.bMirror);
                }           
</pre></div><h2><a class="anchor" id="bkrec_class_cyclic_buf"></a>
Class CyclicBuffer</h2>
<p>The CyclicBuffer class provides the cyclic buffer for this sample program. The program can write frames to the buffer, and then read frames back from the buffer to dump them to output files.</p>
<p><code>m_pFrames </code> is the data structure actually implementing the cyclic buffer.</p>
<p>At this point the reader may find it useful to already study <a class="el" href="smpl_back_recrdr.html#bkrec_class_cyc_decl_blk">Declaration Block for the CyclicBuffer Class</a> to learn the meaning of data structure and then return here to continue learning the code of the <code>CyclicBuffer</code> class in order.</p>
<h3><a class="anchor" id="bkrec_class_cyc_construct"></a>
Class Constructor</h3>
<p>This constructor sets up references to the generator nodes that are parsed as parameters to this constructor, as follows. </p>
<div class="fragment"><pre class="fragment">                CyclicBuffer(<a class="code" href="classxn_1_1_context.html">xn::Context</a>&amp; context, <a class="code" href="classxn_1_1_depth_generator.html">xn::DepthGenerator</a>&amp; depthGenerator, <a class="code" href="classxn_1_1_image_generator.html">xn::ImageGenerator</a>&amp; imageGenerator,
                    <span class="keyword">const</span> RecConfiguration&amp; config) :
                                m_context(context),
                                m_depthGenerator(depthGenerator),
                                m_imageGenerator(imageGenerator)
</pre></div><h3><a class="anchor" id="bkrec_class_cyc_init"></a>
Initialize() method</h3>
<p>This method initializes the <code>m_pFrames</code> cyclic buffer and also the output directory path. <code> xnOSStrCopy ()</code> copies one string from the other, making a local copy of the output path. The buffer size is in number of frames (seconds x 30 FPS). </p>
<div class="fragment"><pre class="fragment">                <span class="keywordtype">void</span> Initialize(XnChar* strDirName, XnUInt32 nSeconds)
                {
                    <a class="code" href="_xn_o_s_strings_8h.html#a70efc093f0c75ba737cd61e5e2a0d9f3">xnOSStrCopy</a>(m_strDirName, strDirName, XN_FILE_MAX_PATH);
                    m_nBufferSize = nSeconds*30;
                    m_pFrames = <a class="code" href="_xn_o_s_8h.html#ac3fa097d0b2210abd09b35451cde3131">XN_NEW_ARR</a>(SingleFrame, m_nBufferSize);
                }
</pre></div><p> This method is invoked from the <a class="el" href="smpl_back_recrdr.html#bkrec_main">main() function</a> main() program function.</p>
<h3><a class="anchor" id="bkrec_class_cyc_init_m_pFrames"></a>
Declaring the &lt;code&gt;m_pFrames&lt;/code&gt; Cyclic Buffer</h3>
<p>In the above Initialize) method, the macro <code><a class="el" href="_xn_o_s_8h.html#ac3fa097d0b2210abd09b35451cde3131">XN_NEW_ARR()</a></code> allocates an array of frames</p>
<p>where the SingleFrame type is defined as follows. </p>
<div class="fragment"><pre class="fragment">                <span class="keyword">struct </span>SingleFrame
                {
                    <a class="code" href="classxn_1_1_depth_meta_data.html">xn::DepthMetaData</a> depthFrame;
                    <a class="code" href="classxn_1_1_image_meta_data.html">xn::ImageMetaData</a> imageFrame;
                };          
</pre></div><p>Thus each entry in the cyclic buffer is a frame comprising a depth map data frame and an image map data frame.</p>
<p>The CyclicBuffer class's declaration block is described in <a class="el" href="smpl_back_recrdr.html#bkrec_class_cyc_decl_blk">Declaration Block for the CyclicBuffer Class</a>.</p>
<h3><a class="anchor" id="bkrec_class_cyc_update"></a>
Update() method</h3>
<p>This method saves new OpenNI data in the cyclic buffer. This method is called from the main program loop, immediately after the WaitAndUpdate() call. See <a class="el" href="conc_updating_data.html#conc_updating_data__sample_code_cmn">Sample Code</a> for the work cycle summary.</p>
<p><b>Function heading:</b> </p>
<div class="fragment"><pre class="fragment">                <span class="keywordtype">void</span> Update(<span class="keyword">const</span> <a class="code" href="classxn_1_1_depth_generator.html">xn::DepthGenerator</a>&amp; depthGenerator, <span class="keyword">const</span> <a class="code" href="classxn_1_1_image_generator.html">xn::ImageGenerator</a>&amp; imageGenerator)
                {
                    ...
                }
</pre></div><p>The following code block gets the latest available data generated by the <a class="el" href="classxn_1_1_depth_generator.html">DepthGenerator</a> node, saving it to a <a class="el" href="glossary.html#glos_frame_object">frame object</a>.</p>
<p><a class="el" href="classxn_1_1_depth_meta_data.html">DepthMetaData</a> provides the <a class="el" href="glossary.html#glos_frame_object">frame object</a> for the <a class="el" href="classxn_1_1_depth_generator.html">DepthGenerator</a> node. The <a class="el" href="glossary.html#glos_frame_object">frame object</a> provides access to a snapshot of a <a class="el" href="glossary.html#dict_gen_node">generator node's</a> data frame and all its associated properties.</p>
<p>If requested, this code copies the DepthGenerator frame object to the <code>m_pFrames</code> cyclic buffer. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordflow">if</span> (m_bDepth)
                {
                    <a class="code" href="classxn_1_1_depth_meta_data.html">xn::DepthMetaData</a> dmd;
                    depthGenerator.<a class="code" href="classxn_1_1_depth_generator.html#a0e05087d3c1652e6f7fa4c002807a22a" title="Gets the depth generator node&#39;s latest frame object, saving it in the xn::DepthMetaData object...">GetMetaData</a>(dmd);
                    m_pFrames[m_nNextWrite].depthFrame.CopyFrom(dmd);
                }
</pre></div><p>As for the DepthGenerator above, the following code block gets the latest available data generated by the <a class="el" href="classxn_1_1_image_generator.html">ImageGenerator</a> node, saving it to a <a class="el" href="glossary.html#glos_frame_object">frame object</a>.</p>
<p>The rest of the code in this function manages the indexes of the cyclic buffer.</p>
<h3><a class="anchor" id="bkrec_class_cyc_dump"></a>
Dump() method</h3>
<p>This method saves the current state of the cyclic buffer to a file. This method sets up a <a class="el" href="classxn_1_1_recorder.html">Recorder</a> node and that makes the program record all data generated from the mock nodes. Recording means saving all the data to a disk file. The <a class="el" href="classxn_1_1_recorder.html#a94a2c702fd2c5e2466b813bb585e6fc9">Recorder.Record()</a> method has to be called to save each frame.</p>
<p>This method is called from the main program loop as a user menu option.</p>
<p><b>Function heading:</b> </p>
<div class="fragment"><pre class="fragment">                <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> Dump()
                {
                    ...
                }
</pre></div><h4><a class="anchor" id="bkrec_class_cyc_dump_decls"></a>
Declarations</h4>
<p>The following declares mock nodes: <a class="el" href="classxn_1_1_mock_depth_generator.html">MockDepthGenerator</a> for the <a class="el" href="classxn_1_1_depth_generator.html">DepthGenerator</a> node and <a class="el" href="classxn_1_1_mock_image_generator.html">MockImageGenerator</a> for the <a class="el" href="classxn_1_1_image_generator.html">ImageGenerator</a> node. These are to simulate the actual nodes when recording or playing data from a recording. A mock node does not contain any logic for generating data. Instead, it allows an outside component (such as an application or a real node implementation) to feed it data and configuration changes. </p>
<div class="fragment"><pre class="fragment">                    <a class="code" href="classxn_1_1_mock_depth_generator.html">xn::MockDepthGenerator</a> mockDepth;
                    <a class="code" href="classxn_1_1_mock_image_generator.html">xn::MockImageGenerator</a> mockImage;
</pre></div><p>The <a class="el" href="classxn_1_1_enumeration_errors.html">EnumerationErrors</a> and <a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> declarations at the top of the main program collect and report status and errors from OpenNI operations. </p>
<div class="fragment"><pre class="fragment">                    <a class="code" href="classxn_1_1_enumeration_errors.html">xn::EnumerationErrors</a> errors;
                    <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> rc;
</pre></div><h4><a class="anchor" id="bkrec_class_cyc_dump_decls"></a>
Declarations</h4>
<p><a class="el" href="classxn_1_1_context.html#a4dba9b1553322cfb4ecdff6b6c93a182">CreateAnyProductionTree()</a> method creates a <a class="el" href="classxn_1_1_recorder.html">Recorder</a> node. The <code>m_recorder</code> parameter returns a reference to a Recorder node. </p>
<div class="fragment"><pre class="fragment">                    rc = m_context.CreateAnyProductionTree(<a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52ab692ee9629e719de76e3667fd628a2ab">XN_NODE_TYPE_RECORDER</a>, NULL, m_recorder, &amp;errors);
</pre></div><h4><a class="anchor" id="bkrec_class_cyc_setsup_rec_dest"></a>
bkrec_class_cyc_setsup_rec_dest</h4>
<p>In the following statement, the call to <a class="el" href="classxn_1_1_recorder.html#a1e84f796966c9808b2a26db0d5dfe621">SetDestination()</a> specifies to where the recorder must send its recording. This is a disk file of a particular file type. </p>
<div class="fragment"><pre class="fragment">                    m_recorder.SetDestination(<a class="code" href="group__recorder.html#gga3a9ee4c35a7384ba06a4d22f976f8e8aab2fd201e9160a675b83ca2a3e4d36a0c">XN_RECORD_MEDIUM_FILE</a>, strFileName);
</pre></div><h4><a class="anchor" id="bkrec_class_cyc_crt_mock_nodes"></a>
bkrec_class_cyc_crt_mock_nodes</h4>
<p>If requested, in the following code block, <a class="el" href="classxn_1_1_context.html#ad3d8f78cf331911c3b1568d7546ab6e0">CreateMockNodeBasedOn()</a> creates a mock node based on the <a class="el" href="classxn_1_1_depth_generator.html">DepthGenerator</a> node. This means the properties of the original DepthGenerator object will be copied to the newly created MockDepthGenerator, and it is required to make the mock depth generator work properly.</p>
<p><a class="el" href="classxn_1_1_recorder.html#aa6023d6f933e831504c6ddaa8357927f">AddNodeToRecording()</a> adds the <code>mockDepth</code> node to the recording setup, and starts recording data that the node generates. </p>
<div class="fragment"><pre class="fragment">                    <span class="keywordflow">if</span> (m_bDepth)
                    {
                        rc = m_context.CreateMockNodeBasedOn(m_depthGenerator, NULL, mockDepth);
                        rc = m_recorder.AddNodeToRecording(mockDepth, <a class="code" href="_xn_codec_i_ds_8h.html#aba0b76d523d3ad9c58d8f7333016e787">XN_CODEC_16Z_EMB_TABLES</a>);
                    }
</pre></div><p>If requested, in the following code block, <a class="el" href="classxn_1_1_context.html#ad3d8f78cf331911c3b1568d7546ab6e0">CreateMockNodeBasedOn()</a> creates a mock node based on the <a class="el" href="classxn_1_1_image_generator.html">ImageGenerator</a> node.</p>
<p><a class="el" href="classxn_1_1_recorder.html#aa6023d6f933e831504c6ddaa8357927f">AddNodeToRecording()</a> adds the <code>mockImage</code> node to the recording setup, and starts recording data that the node generates. </p>
<div class="fragment"><pre class="fragment">                    <span class="keywordflow">if</span> (m_bDepth)
                    {
                        rc = m_context.CreateMockNodeBasedOn(m_imageGenerator, NULL, mockImage);
                        rc = m_recorder.AddNodeToRecording(mockImage, <a class="code" href="_xn_codec_i_ds_8h.html#a9dd32da2907ebe7cae19a3e90b16275e">XN_CODEC_JPEG</a>);
                    }
</pre></div><h4><a class="anchor" id="bkrec_class_cyc_write_frames"></a>
bkrec_class_cyc_write_frames</h4>
<p>The following loops record all the frames that are in the cyclic buffer. The <a class="el" href="classxn_1_1_recorder.html#a94a2c702fd2c5e2466b813bb585e6fc9">Record()</a>method has to be called to save each frame.</p>
<p>This block is executed only if the <code>m_nNextWrite</code> index has wrapped around. In this case, the method must record the remainder of the nodes until the end of the cyclic buffer. Then the method must start again from <code>0</code> until the most recent node that was written. </p>
<div class="fragment"><pre class="fragment">                    <span class="keywordflow">if</span> (m_nNextWrite &lt; m_nBufferCount) 
                       <span class="keywordflow">for</span> (XnUInt32 i = m_nNextWrite; i &lt; m_nBufferSize; ++i)
                         ...
                    
                    <span class="keywordflow">for</span> (XnUInt32 i = 0; i &lt; m_nNextWrite; ++i)
                        ...
</pre></div><p>In both the above loops the <a class="el" href="classxn_1_1_mock_depth_generator.html#a5e4b631fc5a3f5434a21582028888e12">MockDepthGenerator.SetData()</a> method copies all the frame data from the cyclic buffer into the two mock nodes. </p>
<div class="fragment"><pre class="fragment">                    mockDepth.<a class="code" href="classxn_1_1_mock_depth_generator.html#a5e4b631fc5a3f5434a21582028888e12">SetData</a>(m_pFrames[i].depthFrame);
                    mockImage.<a class="code" href="classxn_1_1_mock_image_generator.html#a90390641f983b52fdca2c779f5e5d9f0">SetData</a>(m_pFrames[i].imageFrame);
</pre></div><p>On completion of the record loops, the following code block unreferences each of the production nodes below, for each node decreasing its reference count by 1. If the reference count of any of the nodes reaches zero, OpenNI destroys the node. </p>
<div class="fragment"><pre class="fragment">                    m_recorder.Release();
                    mockImage.<a class="code" href="classxn_1_1_node_wrapper.html#ad94e45cb0bbd21223ed17e77c6893ca6">Release</a>();
                    mockDepth.<a class="code" href="classxn_1_1_node_wrapper.html#ad94e45cb0bbd21223ed17e77c6893ca6">Release</a>();
</pre></div><p>If excution of the <code>Dump()</code> method got this far, it must have been successful. </p>
<div class="fragment"><pre class="fragment">                    <span class="keywordflow">return</span> <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>;
</pre></div><h3><a class="anchor" id="bkrec_class_cyc_decl_blk"></a>
Declaration Block for the CyclicBuffer Class</h3>
<p>Following is the declaration block for the <code>CyclicBuffer </code>Class.</p>
<div class="fragment"><pre class="fragment">                <span class="keyword">struct </span>SingleFrame
                {
                    <a class="code" href="classxn_1_1_depth_meta_data.html">xn::DepthMetaData</a> depthFrame;
                    <a class="code" href="classxn_1_1_image_meta_data.html">xn::ImageMetaData</a> imageFrame;
                };

                XnBool m_bDepth, m_bImage;
                SingleFrame* m_pFrames;
                XnUInt32 m_nNextWrite;
                XnUInt32 m_nBufferSize;
                XnUInt32 m_nBufferCount;
                XnChar m_strDirName[XN_FILE_MAX_PATH];

                <a class="code" href="classxn_1_1_context.html">xn::Context</a>&amp; m_context;
                <a class="code" href="classxn_1_1_depth_generator.html">xn::DepthGenerator</a>&amp; m_depthGenerator;
                <a class="code" href="classxn_1_1_image_generator.html">xn::ImageGenerator</a>&amp; m_imageGenerator;
                <a class="code" href="classxn_1_1_recorder.html">xn::Recorder</a> m_recorder;
</pre></div><p>The <code>RecConfiguration</code> struct's fields and initializations are described in the following table. Only the data items comprising OpenNI elements are listed. </p>
<table class="doxtable">
<tr>
<th>Item </th><th>Description  </th></tr>
<tr>
<td><code>SingleFrame</code> </td><td>This is a single frame of the <code>m_pFrames</code> cyclic buffer. The frame contains a <a class="el" href="classxn_1_1_depth_meta_data.html">DepthMetaData</a> <a class="el" href="glossary.html#glos_frame_object">Frame Objects</a> and a <a class="el" href="classxn_1_1_image_generator.html">ImageGenerator</a> <a class="el" href="glossary.html#glos_frame_object">Frame Objects</a>.  </td></tr>
<tr>
<td><code>m_pFrames</code> </td><td>This is the cyclic buffer data structure itself.  </td></tr>
<tr>
<td><code>XnChar m_strDirName[XN_FILE_MAX_PATH]</code> </td><td>To hold the output file name.   </td></tr>
<tr>
<td><code><a class="el" href="classxn_1_1_context.html">xn::Context</a>&amp; m_context;</code> </td><td>Declares a local reference within the CyclicBuffer class to call the CreateAnyProductionTree() method. See <a class="el" href="smpl_back_recrdr.html#bkrec_cfg_gens">ConfigureGenerators() function</a>.  </td></tr>
<tr>
<td><code><a class="el" href="classxn_1_1_depth_generator.html">xn::DepthGenerator</a>&amp; m_depthGenerator;</code> </td><td>Declares a reference within the CyclicBuffer object to assign a DepthGenerator <a class="el" href="glossary.html#glos_frame_object">frame object</a> to the CyclicBuffer. See <a class="el" href="smpl_back_recrdr.html#bkrec_cfg_gens">ConfigureGenerators() function</a>.  </td></tr>
<tr>
<td><code><a class="el" href="classxn_1_1_image_generator.html">xn::ImageGenerator</a>&amp; m_imageGenerator;</code> </td><td>Declares a reference within the CyclicBuffer object to assign an ImageGenerator <a class="el" href="glossary.html#glos_frame_object">frame object</a> to the CyclicBuffer. See <a class="el" href="smpl_back_recrdr.html#bkrec_cfg_gens">ConfigureGenerators() function</a>.  </td></tr>
<tr>
<td><code><a class="el" href="classxn_1_1_recorder.html">xn::Recorder</a> m_recorder;</code> </td><td>The Recorder node for saving the frame data generated by the production graph. See <a class="el" href="smpl_back_recrdr.html#bkrec_cfg_gens">ConfigureGenerators() function</a>.  </td></tr>
</table>
<h2><a class="anchor" id="bkrec_main"></a>
main() function</h2>
<p>The OpenNi objects. For description see <a class="el" href="smpl_back_recrdr.html#bkrec_cfg_gens">ConfigureGenerators() function</a>. </p>
<div class="fragment"><pre class="fragment">            <a class="code" href="classxn_1_1_context.html">xn::Context</a> context;
            <a class="code" href="classxn_1_1_depth_generator.html">xn::DepthGenerator</a> depthGenerator;
            <a class="code" href="classxn_1_1_image_generator.html">xn::ImageGenerator</a> imageGenerator;
</pre></div><p><b>To count missed frames: </b> Not OpenNI specific.</p>
<p><b>RecConfiguration config;</b> See <a class="el" href="smpl_back_recrdr.html#bkrec_decls">Program Declarations</a>.</p>
<p><b>Parse the command line arguments: </b> Not OpenNI specific.</p>
<p><b>Turn on log: </b></p>
<p><b>Initialize OpenNI: </b> </p>
<div class="fragment"><pre class="fragment">            nRetVal = context.<a class="code" href="classxn_1_1_context.html#adfc68c424c840a788d0903e20a95e541" title="Builds the context&#39;s general software environment.">Init</a>();
</pre></div><p>Configure the generator nodes. </p>
<div class="fragment"><pre class="fragment">            nRetVal = ConfigureGenerators(config, context, depthGenerator, imageGenerator);
</pre></div><p>Ensures all created <a class="el" href="glossary.html#dict_gen_node">Generator Node</a> generators are generating data. </p>
<div class="fragment"><pre class="fragment">            nRetVal = context.<a class="code" href="classxn_1_1_context.html#affa5173b7c32b98d344ab2c8634f2cb7" title="Ensures all created generator nodes are generating data.">StartGeneratingAll</a>();
</pre></div><p>Create and initialize the cyclic buffer. See <a class="el" href="smpl_back_recrdr.html#bkrec_class_cyc_construct">Class Constructor</a> and <a class="el" href="smpl_back_recrdr.html#bkrec_class_cyc_init">Initialize() method</a>. </p>
<div class="fragment"><pre class="fragment">            CyclicBuffer cyclicBuffer(context, depthGenerator, imageGenerator, config);
            cyclicBuffer.Initialize(config.strDirName, config.nDumpTime);
</pre></div><h3><a class="anchor" id="bkrec_main"></a>
main() function</h3>
<p>Here is the main loop. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordflow">while</span> (1)
                {
                    ...
                }
</pre></div><p>The following call to a 'Wait And Update All' method updates the data available for output. The <a class="el" href="classxn_1_1_context.html#a52929d2a535166b18098e066900f9d59">WaitAndUpdateAll()</a> method updates all generator nodes in the context's Production Graph to the latest available data, first waiting for all nodes to have new data available. (In this sample the Production Graph is the DepthGenerator and ImageGenerator.) The application then reads this data through the frame object. </p>
<div class="fragment"><pre class="fragment">                context.<a class="code" href="classxn_1_1_context.html#a52929d2a535166b18098e066900f9d59" title="Updates all generator nodes in the context to their latest available data, first waiting for all node...">WaitAndUpdateAll</a>();
</pre></div> </div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue Nov 12 2013 16:35:27 for OpenNI 1.5.7 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
